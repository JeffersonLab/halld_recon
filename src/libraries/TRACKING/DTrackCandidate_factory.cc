// $Id$
//
//    File: DTrackCandidate_factory.cc
// Created: Mon Jul 18 15:23:04 EDT 2005
// Creator: davidl (on Darwin wire129.jlab.org 7.8.0 powerpc)
//

/// Factory to match track candidates generated by the FDC- and CDC-specific 
/// track finding codes.
///
/// If a match is found, the code attempts to improve the track parameters by
/// redoing the Riemann Circle fit with the additional hits.  If an fdc 
/// candidate is matched to a cdc candidate, or several previously unused hits
/// are added to the track, the code attempts to place the "start" position 
/// parameters of the track at a radius just outside the start counter.

#include <cmath>
using namespace std;

#include "DTrackCandidate_factory.h"

#include <JANA/JEvent.h>
#include <JANA/Calibrations/JCalibrationManager.h>
#include <JANA/Services/JLockService.h>
#include "DANA/DGeometryManager.h"
#include "HDGEOMETRY/DGeometry.h"
#include <CDC/DCDCTrackHit.h>

#include <TROOT.h>
#include <TH2F.h>

#define CUT 10.
#define RADIUS_CUT 50.0
#define EPS 0.001

//------------------
// SegmentSortByLayerincreasing
//------------------
inline bool SegmentSortByLayerincreasing(const DFDCSegment* const &segment1, const DFDCSegment* const &segment2) {
	// Compare DFDCSegment->DFDCPseudo[0]->DFDCWire->layer
	int layer1 = 100; // defaults just in case there is a segment with no hits
	int layer2 = 100;
	
	if(segment1->hits.size()>0)layer1=segment1->hits[0]->wire->layer;
	if(segment2->hits.size()>0)layer2=segment2->hits[0]->wire->layer;

	return layer1 < layer2;
}

//------------------
// CDCHitSortByLayerincreasing
//------------------
inline bool CDCHitSortByLayerincreasing(const DCDCTrackHit* const &hit1, const DCDCTrackHit* const &hit2) {
	// Used to sort CDC hits by layer (ring) with innermost layer hits first

	// if same ring, sort by wire number
	if(hit1->wire->ring == hit2->wire->ring)
	{
		if(hit1->wire->straw == hit2->wire->straw)
			return (hit1->dE > hit2->dE);
		return hit1->wire->straw < hit2->wire->straw;
	}

	return hit1->wire->ring < hit2->wire->ring;
}

//------------------
// FDCHitSortByLayerincreasing
//------------------
inline bool FDCHitSortByLayerincreasing(const DFDCPseudo* const &hit1, const DFDCPseudo* const &hit2) {
  // Used to sort FDC hits by layer with most upstream layer hits first  
  // if same layer, sort by wire number
  if(hit1->wire->layer == hit2->wire->layer)
    {
      if(hit1->wire->wire == hit2->wire->wire)
	return (hit1->dE > hit2->dE);
      return (hit1->wire->wire < hit2->wire->wire);
    }
  
  return hit1->wire->layer < hit2->wire->layer;
}

//------------------
// Init
//------------------
void DTrackCandidate_factory::Init()
{
  auto app = GetApplication();

  MAX_NUM_TRACK_CANDIDATES = 20;
  
  BEAM_VAR=1.;
  app->SetDefaultParameter("TRKFIND:BEAM_VAR",BEAM_VAR);
}

//------------------
// BeginRun
//------------------
void DTrackCandidate_factory::BeginRun(const std::shared_ptr<const JEvent>& event){

  auto run_number = event->GetRunNumber();
  auto app = GetApplication();
  auto root_lock = app->GetService<JLockService>();
  auto jcalib = app->GetService<JCalibrationManager>()->GetJCalibration(run_number);
  auto geo_manager = app->GetService<DGeometryManager>();
  auto dgeom = geo_manager->GetDGeometry(run_number);
  bfield = geo_manager->GetBfield(run_number);

  FactorForSenseOfRotation=(bfield->GetBz(0.,0.,65.)>0.)?-1.:1.;

  dIsNoFieldFlag = (dynamic_cast<const DMagneticFieldMapNoField*>(bfield) != NULL);
  if(dIsNoFieldFlag)
  {
    //Setting this flag makes it so that JANA does not delete the objects in mData.  This factory will manage this memory.
      //This is all of these pointers are just copied from the "StraightLine" factory, and should not be re-deleted.
    SetFactoryFlag(NOT_OBJECT_OWNER);
  }
  else
    ClearFactoryFlag(NOT_OBJECT_OWNER); //This factory will create it's own objects.

  map<string, double> targetparms;
  if (jcalib->Get("TARGET/target_parms",targetparms)==false){
    TARGET_Z = targetparms["TARGET_Z_POSITION"];
   }
  else{
    dgeom->GetTargetZ(TARGET_Z);
  }

  app->SetDefaultParameter("TRKFIND:MAX_NUM_TRACK_CANDIDATES", MAX_NUM_TRACK_CANDIDATES); 

  //  MIN_NUM_HITS=6;
  //app->SetDefaultParameter("TRKFIND:MIN_NUM_HITS", MIN_NUM_HITS);
  
  DEBUG_LEVEL=0;
  app->SetDefaultParameter("TRKFIND:DEBUG_LEVEL", DEBUG_LEVEL);

  ADD_VERTEX_POINT=true;
  app->SetDefaultParameter("TRKFIND:ADD_VERTEX_POINT", ADD_VERTEX_POINT);

  FDC_MATCH_CUT=0.5;
  CDC_MATCH_CUT=0.8;
  app->SetDefaultParameter("TRKFIND:FDC_MATCH_CUT",FDC_MATCH_CUT);
  app->SetDefaultParameter("TRKFIND:CDC_MATCH_CUT",CDC_MATCH_CUT);
   
  return;
}

//------------------
// EndRun
//------------------
void DTrackCandidate_factory::EndRun()
{
}

//------------------
// EndRun
//------------------
void DTrackCandidate_factory::Finish()
{
}



//------------------
// Process
//------------------
void DTrackCandidate_factory::Process(const std::shared_ptr<const JEvent>& event)
{
  if(dIsNoFieldFlag)
  {
    //Clear previous objects: //JANA doesn't do it because NOT_OBJECT_OWNER was set
	  //It DID delete them though, in the "StraightLine" factory
    mData.clear();

    vector<const DTrackCandidate*> locStraightLineCandidates;
    event->Get(locStraightLineCandidates, "StraightLine");
    for(size_t loc_i = 0; loc_i < locStraightLineCandidates.size(); ++loc_i)
      mData.push_back(const_cast<DTrackCandidate*>(locStraightLineCandidates[loc_i]));
    return;
  }
  
  // Get the track candidates from the CDC and FDC candidate finders
  vector<const DTrackCandidate*>cdctrackcandidates;
  event->Get(cdctrackcandidates, "CDC");
  vector<const DTrackCandidate*>fdctrackcandidates;
  event->Get(fdctrackcandidates, "FDCCathodes");

  // List of cdc hits
  vector<const DCDCTrackHit *>allcdchits;
  event->Get(allcdchits);

  // Vector to keep track of cdc hits used in candidates
  vector<unsigned int>used_cdc_hits(allcdchits.size());
  for(unsigned int i=0; i<cdctrackcandidates.size(); i++){ 
    const DTrackCandidate *srccan = cdctrackcandidates[i];
    for (unsigned int n=0;n<srccan->used_cdc_indexes.size();n++){
      used_cdc_hits[srccan->used_cdc_indexes[n]]=1;
    }
  }
  unsigned int num_unmatched_cdcs=0;
  for (unsigned int i=0;i<used_cdc_hits.size();i++){
    if (used_cdc_hits[i]==0) num_unmatched_cdcs++;
  }
  
  // vector to keep track of the matching status of each fdc candidate
  vector<int>fdc_matches(fdctrackcandidates.size());
  vector<int>cdc_matches(cdctrackcandidates.size());

  // Loop over fdc candidates looking for matches with cdc candidates
  if (cdctrackcandidates.size()>0){
    for (unsigned int i=0;i<fdctrackcandidates.size();i++){
      if (fdc_matches[i]) continue;
      
      // FDC candidate not already used -- let's proceed.
      const DTrackCandidate *fdccan=fdctrackcandidates[i];
      if (fdccan->FirstPackage>0) continue;
      
      // Loop over cdc candidates
      for (unsigned int j=0;j<cdctrackcandidates.size();j++){
	if (cdc_matches[j]) continue;
	
	// CDC candidate not already used -- let's proceed.
	const DTrackCandidate *cdccan=cdctrackcandidates[j];

	// Various checks to try to prevent false matches
	if (fdccan->dPosition.x()*cdccan->dPosition.x()<0) continue;
	if (fdccan->dPosition.y()*cdccan->dPosition.y()<0) continue;
	double fdc_r2=fdccan->dPosition.Perp2();
	if (fdc_r2<cdccan->dPosition.Perp2()) continue;
	DVector3 last_cdc_pos=cdccan->cdchits[cdccan->cdchits.size()-1]->wire->origin;
	if (last_cdc_pos.Perp2()>fdc_r2) continue;
	
	// The following code snippet is intended to prevent matching a cdc
	// track candidate to a low momentum particle curling from the cdc endplate  
	double theta=fdccan->dMomentum.Theta();
	double p_fdc=fdccan->dMomentum.Mag();
	if (fdccan->LastPackage>0 && (p_fdc<0.3 || fdc_r2>120.) && theta< 5.*M_PI/180.){
	  continue;
	}
	
	// loop over the cdc hits and count hits that agree with a projection of 
	// the helix into the cdc
	vector<const DCDCTrackHit*>cdchits=cdccan->cdchits;
	unsigned int num_matches=0;
	for (unsigned int m=0;m<cdchits.size();m++){
	  DVector3 wirepos=cdchits[m]->wire->origin;
	  if (cdchits[m]->is_stereo){
	    GetCDCIntersection(cdccan,cdchits[m],wirepos);
	  }
	  double dr=sqrt(pow(wirepos.x()-fdccan->xc,2)
			 +pow(wirepos.y()-fdccan->yc,2))-fdccan->rc;
	  if (fabs(dr)<CDC_MATCH_CUT) num_matches++;
	}
	// List of FDC hits attached to track candidate
	vector<const DFDCPseudo*>fdchits=fdccan->fdchits;
	if (num_matches<3){
	  // Try using the cdc candidate to match to fdc hits
	  num_matches=0;
	  for (unsigned int m=0;m<fdchits.size();m++){
	    const DFDCPseudo *hit=fdchits[m];
	    double dr=sqrt(pow(hit->xy.X()-cdccan->xc,2)
			   +pow(hit->xy.Y()-cdccan->yc,2))-cdccan->rc;
	    if (fabs(dr)<FDC_MATCH_CUT) num_matches++;
	  }
	}
	// If there is no match, redo circle fit for cdc candidate requiring
	// the circle to go through the origin
	if (num_matches<3){
	  DHelicalFit fit;
	  for (unsigned int k=0;k<cdchits.size();k++){	
	    if (cdchits[k]->is_stereo==false){
	      double cov=1.6*1.6/12.;  //guess
	      DVector3 pos=cdchits[k]->wire->origin;
	      fit.AddHitXYZ(pos.x(),pos.y(),pos.z(),cov,cov,0.,true);
	    }
	  }
	  fit.FitCircle();
	  num_matches=0;
	  for (unsigned int m=0;m<fdchits.size();m++){
	    const DFDCPseudo *hit=fdchits[m];
	    double dr=sqrt(pow(hit->xy.X()-fit.x0,2)
			   +pow(hit->xy.Y()-fit.y0,2))-fit.r0;
	    if (fabs(dr)<FDC_MATCH_CUT) num_matches++;
	  }
	}
	// If there is no match, redo circle fit for fdc candidate requiring
	// the circle to go through the origin
	if (num_matches<3){
	  DHelicalFit fit;
	  for (unsigned int k=0;k<fdchits.size();k++){	
	    const DFDCPseudo *fdchit=fdchits[k];
	    fit.AddHit(fdchit);
	  }
	  fit.FitCircle();
	  num_matches=0;
	  for (unsigned int m=0;m<cdchits.size();m++){
	    DVector3 wirepos=cdchits[m]->wire->origin;
	    if (cdchits[m]->is_stereo){
	      GetCDCIntersection(cdccan,cdchits[m],wirepos);
	    }
	    double dr=sqrt(pow(wirepos.x()-fit.x0,2)
			   +pow(wirepos.y()-fit.y0,2))-fit.r0;
	    if (fabs(dr)<CDC_MATCH_CUT) num_matches++;
	  }
	}
	if (num_matches>=3){	
	  DVector3 pos=fdccan->dPosition;
	  DVector3 mom=fdccan->dMomentum;
	  // Create a new DHelicalFit object for fitting combined data
	  DHelicalFit fit;
	  DoRefit(fit,fdccan,fdchits,cdchits,mom,pos);
	  
	  // Create new track candidate object 
	  DTrackCandidate *can = new DTrackCandidate;
	  
	  // circle parameters
	  can->rc=fit.r0;
	  can->xc=fit.x0;
	  can->yc=fit.y0;
	  
	  // Add cdc and fdc hits to the track as associated objects
	  can->fdchits=std::move(fdccan->fdchits);
	  can->LastPackage=fdccan->LastPackage;
	  can->cdchits=std::move(cdccan->cdchits);
	  
	  can->dMinimumDriftTime=fdccan->dMinimumDriftTime;
	  can->dDetector=SYS_FDC;
	  if (cdccan->dMinimumDriftTime<fdccan->dMinimumDriftTime){
	    can->dDetector=SYS_CDC;
	    can->dMinimumDriftTime=cdccan->dMinimumDriftTime;
	  }
	  
	  can->chisq=fit.chisq;
	  can->Ndof=fit.ndof;
	  
	  can->dCharge=FactorForSenseOfRotation*fit.h;
	  can->dMomentum=mom;
	  can->dPosition=pos;
	  
	  Insert(can);
	
	  fdc_matches[i]=1;
	  cdc_matches[j]=1;
	}
      } // loop over cdc candidates
    } // loop over fdc candidates
  } // check if there are cdc candidates
  
  // If there are unused CDC hits not associated with a track, try to
  // connect them to FDC candidates that have not already been matched
  // to CDC candidates
  if (num_unmatched_cdcs>0){
    for (unsigned int i=0;i<fdctrackcandidates.size();i++){
      if (num_unmatched_cdcs<1) break;
      if (fdc_matches[i]) continue;
      
      // FDC candidate not already used -- let's proceed.
      const DTrackCandidate *fdccan=fdctrackcandidates[i];
      if (fdccan->FirstPackage>0) continue;
      
      vector<const DCDCTrackHit*>cdchits;
      int num_axial=0;
      for (unsigned int k=0;k<used_cdc_hits.size();k++){
	if (used_cdc_hits[k]) continue;

	// Look for a match
	DVector3 wirepos=allcdchits[k]->wire->origin;
	// Skip hits on the other side the target
	if (fdccan->dPosition.x()*wirepos.x()<0) continue;
	if (fdccan->dPosition.y()*wirepos.y()<0) continue;
	// Skip hits whose radial positions are out larger than the reported
	// fdc candidate position
	if (wirepos.Perp2()>fdccan->dPosition.Perp2()) continue;
	
	double dr=sqrt(pow(wirepos.x()-fdccan->xc,2)
		       +pow(wirepos.y()-fdccan->yc,2))-fdccan->rc;
	double cut=(allcdchits[k]->is_stereo)?9.57*CDC_MATCH_CUT:CDC_MATCH_CUT;
	if (fabs(dr)<cut){
	  num_unmatched_cdcs--;
	  used_cdc_hits[k]=1;
	  if (allcdchits[k]->is_stereo==false) num_axial++;
	  
	  cdchits.push_back(allcdchits[k]);
	}
      }
      if (cdchits.size()>0){
	fdc_matches[i]=1;

	// Position and momentum
	DVector3 pos=fdccan->dPosition;
	DVector3 mom=fdccan->dMomentum;
	// Helical fit information from fdc candidate
	DHelicalFit fit;
	fit.x0=fdccan->xc;
	fit.y0=fdccan->yc;
	fit.r0=fdccan->rc;
	fit.tanl=tan(M_PI_2-mom.Theta());
	fit.h=fdccan->dCharge*FactorForSenseOfRotation;
	// Get the magnetic field at pos
	double Bz=fabs(bfield->GetBz(pos.x(),pos.y(),pos.z()));
	if (num_axial>2){ // Refit if we added several cdc axial hits
	  vector<const DFDCPseudo*>fdchits=fdccan->fdchits;
	  DoRefit(fit,fdccan,fdchits,cdchits,mom,pos);
	}
	else{
	  // Update position and momentum at the start counter barrel radius
	  UpdatePositionAndMomentum(fit,Bz,cdchits[0]->wire->origin,pos,mom);
	}
	  
	// Create new track candidate object 
	DTrackCandidate *can = new DTrackCandidate;

	// circle parameters
	can->rc=fit.r0;
	can->xc=fit.x0;
	can->yc=fit.y0;
	
	// Add cdc and fdc hits to the track as associated objects
	can->fdchits=std::move(fdccan->fdchits);
	can->LastPackage=fdccan->LastPackage;

	double minDriftTime=fdccan->dMinimumDriftTime;
	can->dDetector=SYS_FDC;
	for (unsigned int n=0;n<cdchits.size();n++){
	  can->cdchits.push_back(cdchits[n]);
	  if (cdchits[n]->tdrift){
	    minDriftTime=cdchits[n]->tdrift;
	    can->dDetector=SYS_CDC;
	  }
	}
	can->dMinimumDriftTime=minDriftTime;
	
	can->chisq=fdccan->chisq;
	can->Ndof=fdccan->Ndof;
    
	can->dCharge=fdccan->dCharge;
	can->dMomentum=mom;
	can->dPosition=pos;
	
	Insert(can);
      }
    }
  }

  // Do a final pass to match unmatched FDC candidates to other candidates 
  for (unsigned int i=0;i<mData.size();i++){
    // Get the associated hits
    vector<const DFDCPseudo*>fdchits=mData[i]->fdchits;
    vector<const DCDCTrackHit*>cdchits=mData[i]->cdchits;
   
    for (unsigned int j=0;j<fdctrackcandidates.size();j++){
      if (fdc_matches[j]) continue;

      const DTrackCandidate *fdccan=fdctrackcandidates[j];
      if (fdccan->FirstPackage==mData[i]->LastPackage+1){
	// Find matches to CDC hits
	unsigned int num_matches=0;
	for (unsigned int k=0;k<cdchits.size();k++){
	  // Look for a match
	  DVector3 wirepos=cdchits[k]->wire->origin;
	  if (cdchits[k]->is_stereo){
	    GetCDCIntersection(mData[i],cdchits[k],wirepos);
	  }
	  double dr=sqrt(pow(wirepos.x()-fdccan->xc,2)
			 +pow(wirepos.y()-fdccan->yc,2))-fdccan->rc;
	  if (fabs(dr)<CDC_MATCH_CUT) num_matches++;
	}
	// Find matches to FDC hits
	for (unsigned int k=0;k<fdchits.size();k++){
	  // Look for a match
	  double dr=sqrt(pow(fdchits[k]->xy.X()-fdccan->xc,2)
			 +pow(fdchits[k]->xy.Y()-fdccan->yc,2))-fdccan->rc;
	  if (fabs(dr)<FDC_MATCH_CUT) num_matches++;
	}
	if (num_matches<3){
	  num_matches=0;
	  for (unsigned int k=0;k<fdccan->fdchits.size();k++){
	    // Look for a match
	    const DFDCPseudo *fdchit=fdccan->fdchits[k];
	    double dr=sqrt(pow(fdchit->xy.X()-mData[i]->xc,2)
			   +pow(fdchit->xy.Y()-mData[i]->yc,2))-mData[i]->rc;
	    if (fabs(dr)<FDC_MATCH_CUT) num_matches++;
	  }
	}
	if (num_matches<3){
	  // Refit assuming the circle goes through the origin
	  DHelicalFit fit;
	  for (unsigned int k=0;k<cdchits.size();k++){
	    if (cdchits[k]->is_stereo==false){
	      double cov=1.6*1.6/12.;  //guess
	      DVector3 pos=cdchits[k]->wire->origin;
	      fit.AddHitXYZ(pos.x(),pos.y(),pos.z(),cov,cov,0.,true);
	    }
	  }
	  for (unsigned int k=0;k<fdchits.size();k++){
	    const DFDCPseudo *fdchit=fdchits[k];
	    fit.AddHit(fdchit);
	  }
	  fit.FitCircle();
	  num_matches=0;
	  // Get list of hits associated with the fdc candidate
	  vector<const DFDCPseudo*>candidate_fdchits=fdccan->fdchits;
	  for (unsigned int m=0;m<candidate_fdchits.size();m++){
	    const DFDCPseudo *hit=candidate_fdchits[m];
	    double dr=sqrt(pow(hit->xy.X()-fit.x0,2)
			   +pow(hit->xy.Y()-fit.y0,2))-fit.r0;
	    if (fabs(dr)<FDC_MATCH_CUT) num_matches++;
	  }
	}
	// If we got a match, redo the helical fit with the extra hits
	if (num_matches>=3){
	  // List of FDC hits attached to track candidate
	  vector<const DFDCPseudo*>allfdchits=fdccan->fdchits;
	  allfdchits.insert(allfdchits.end(),fdchits.begin(),fdchits.end());
	  
	  DVector3 pos=fdccan->dPosition;
	  DVector3 mom=fdccan->dMomentum;
	  // Create a new DHelicalFit object for fitting combined data
	  DHelicalFit fit;
	  DoRefit(fit,fdccan,allfdchits,cdchits,mom,pos);

	  mData[i]->rc=fit.r0;
	  mData[i]->xc=fit.x0;
	  mData[i]->yc=fit.y0;
	  
	  // Add cdc and fdc hits to the track as associated objects
	  mData[i]->fdchits.insert(mData[i]->fdchits.end(),
				   fdccan->fdchits.begin(),
				   fdccan->fdchits.end());
	  mData[i]->LastPackage=fdccan->LastPackage;
	  mData[i]->cdchits=std::move(cdchits);
	  
	  mData[i]->chisq=fit.chisq;
	  mData[i]->Ndof=fit.ndof;
	  
	  mData[i]->dCharge=FactorForSenseOfRotation*fit.h;
	  mData[i]->dMomentum=mom;
	  mData[i]->dPosition=pos;

	  fdc_matches[j]=1;
	}
      }
    }
  }

  // Add unmatched cdc and fdc candidates to the output list
  for (unsigned int i=0;i<fdctrackcandidates.size();i++){
    if (fdc_matches[i]) continue;

    // Create new track candidate object 
    DTrackCandidate *can = new DTrackCandidate;
    const DTrackCandidate *fdccan=fdctrackcandidates[i];
    
     // circle parameters
    can->rc=fdccan->rc;
    can->xc=fdccan->xc;
    can->yc=fdccan->yc;
    
    can->dMomentum=fdccan->dMomentum;
    can->dPosition=fdccan->dPosition;
    can->dCharge=fdccan->dCharge;
    
    can->chisq=fdccan->chisq;
    can->Ndof=fdccan->Ndof;

    can->dDetector=SYS_FDC;
    can->fdchits=std::move(fdccan->fdchits);
    can->dMinimumDriftTime=fdccan->dMinimumDriftTime;
    
    Insert(can);
  }
  for (unsigned int i=0;i<cdctrackcandidates.size();i++){
    if (cdc_matches[i]) continue;

    // Create new track candidate object 
    DTrackCandidate *can = new DTrackCandidate;
    const DTrackCandidate *cdccan=cdctrackcandidates[i];
    
     // circle parameters
    can->rc=cdccan->rc;
    can->xc=cdccan->xc;
    can->yc=cdccan->yc;
    
    can->dMomentum=cdccan->dMomentum;
    can->dPosition=cdccan->dPosition;
    can->dCharge=cdccan->dCharge;
    
    can->chisq=cdccan->chisq;
    can->Ndof=cdccan->Ndof;
    
    can->dDetector=SYS_CDC;
    can->cdchits=std::move(cdccan->cdchits);
    can->dMinimumDriftTime=cdccan->dMinimumDriftTime;

    Insert(can);
  }
 
  // Limit the number of candidates to pass to the track fitting stage
  if((int(mData.size()) > MAX_NUM_TRACK_CANDIDATES) && (MAX_NUM_TRACK_CANDIDATES >= 0)){
    if (DEBUG_LEVEL>0) _DBG_ << "Number of candidates = " << mData.size()
			     << " > " <<  MAX_NUM_TRACK_CANDIDATES
			     << " --- skipping track fitting! " << endl;
    for(size_t loc_i = 0; loc_i < mData.size(); ++loc_i)
      delete mData[loc_i];
    mData.clear();
  }
}

// Obtain position and momentum at the exit of a given package using the 
// helical track model.
void DTrackCandidate_factory::GetPositionAndMomentum(const DFDCSegment *segment,
						     DVector3 &pos, 
						     DVector3 &mom) const{
  // Position of track segment at last hit plane of package
  double x=segment->xc+segment->rc*cos(segment->Phi1);
  double y=segment->yc+segment->rc*sin(segment->Phi1);
  double z=segment->hits[0]->wire->origin.z();

  // Track parameters
  //double kappa=segment->q/(2.*segment->rc);
  double phi0=segment->phi0;
  double tanl=segment->tanl;
  double z0=segment->z_vertex;

  // Useful intermediate variables
  double cosp=cos(phi0);
  double sinp=sin(phi0);
  double sperp=(z-z0)/tanl;
  //double twoks=2.*kappa*sperp;
  double twoks=FactorForSenseOfRotation*segment->q*sperp/segment->rc;
  double sin2ks=sin(twoks);
  double cos2ks=cos(twoks); 

  // Get Bfield
  double B=fabs(bfield->GetBz(x,y,z));

  // Momentum
  double pt=0.003*B*segment->rc;
  double px=pt*(cosp*cos2ks-sinp*sin2ks);
  double py=pt*(sinp*cos2ks+cosp*sin2ks);
  double pz=pt*tanl;

  pos.SetXYZ(x,y,z);
  mom.SetXYZ(px,py,pz);
}

// Get position and momentum at doca to beam line
void DTrackCandidate_factory::GetPositionAndMomentum(const DHelicalFit &fit,
						     double Bz,
						     DVector3 &pos,
						     DVector3 &mom) const{
  // Find position at doca to beam line
  double phi0=atan2(-fit.x0,fit.y0);
  if (fit.h<0) phi0+=M_PI;
  double sinphi0=sin(phi0);
  double sign=(sinphi0>0)?1.:-1.;
  if (fabs(sinphi0)<1e-8) sinphi0=sign*1e-8;
  double cosphi0=cos(phi0);
  double D=FactorForSenseOfRotation*fit.h*fit.r0-fit.x0/sinphi0;
  double x=-D*sinphi0;
  double y=D*cosphi0;
  double dx=pos.x()-x;
  double dy=pos.y()-y;
  double ratio=sqrt(dx*dx+dy*dy)/(2.*fit.r0);
  double phi_s=(ratio<1.)?2.*asin(ratio):M_PI;
  double newz=pos.z()-phi_s*fit.tanl*fit.r0;
  pos.SetXYZ(x,y,newz);
    
  // momentum at POCA to beam line
  double pt=0.003*Bz*fit.r0;
  mom.SetXYZ(pt*cosphi0,pt*sinphi0,pt*fit.tanl);
}

// Get the position and momentum at a fixed radius from the beam line
jerror_t DTrackCandidate_factory::GetPositionAndMomentum(DHelicalFit &fit,
							 double Bz,
							 const DVector3 &origin,
							 DVector3 &pos,
							 DVector3 &mom) const{
  double r2=65.0;
  double xc=fit.x0;
  double yc=fit.y0;
  double rc=fit.r0;
  double tworc=2.*rc;
  double rc2=rc*rc;
  double xc2=xc*xc;
  double yc2=yc*yc;
  double xc2_plus_yc2=xc2+yc2;
  double A=r2+xc2_plus_yc2-rc2;
  double B=4*r2*xc2_plus_yc2-A*A;
  if (B<0) return VALUE_OUT_OF_RANGE;
	
  double sqrtB=sqrt(B);
  double scale=1./(2.*xc2_plus_yc2);
  double xplus=(xc*A+yc*sqrtB)*scale;
  double xminus=(xc*A-yc*sqrtB)*scale;
  double yplus=(yc*A-xc*sqrtB)*scale;
  double yminus=(yc*A+xc*sqrtB)*scale;

  // Direction tangent and transverse momentum
  double tanl=fit.tanl;
  double pt=0.003*Bz*rc;

  // Choose the solution depending on proximity to one of the cdc hits
  double xwire=origin.x();
  double ywire=origin.y();
  double dx=xminus-xwire;
  double dy=yminus-ywire;
  double d2_minus=dx*dx+dy*dy;
  dx=xplus-xwire;
  dy=yplus-ywire;
  double d2_plus=dx*dx+dy*dy;
  
  DVector3 pos0(pos); // save the input position, for use in finding z
  if (d2_plus>d2_minus){
    pos.SetXYZ(xminus,yminus,0.); // z will be filled later
  }
  else {   
    pos.SetXYZ(xplus,yplus,0.); // z will be filled later
  }
  // Next find the z-position corresponding to the new (x,y) position
  double ratio=(pos0-pos).Perp()/tworc;
  double phi_s=(ratio<1.)?2.*asin(ratio):M_PI;
  pos.SetZ(pos0.z()-phi_s*rc*tanl);
  
  // Get the momentum at the new position
  phi_s*=FactorForSenseOfRotation*fit.h;
  double sin2ks=sin(phi_s);
  double cos2ks=cos(phi_s);
  double phi0=mom.Phi();
  double sinp=sin(phi0);
  double cosp=cos(phi0);
  double cosphi=cosp*cos2ks-sinp*sin2ks;
  double sinphi=sinp*cos2ks+cosp*sin2ks;
  mom.SetXYZ(pt*cosphi,pt*sinphi,pt*tanl);
  
  return NOERROR;
}

// Routine to return momentum and position given the helical parameters and the
// z-component of the magnetic field
void
DTrackCandidate_factory::GetPositionAndMomentum(double z,const DHelicalFit &fit,
						double Bz,DVector3 &pos,
						DVector3 &mom) const{
  double xc=fit.x0;
  double yc=fit.y0;
  double rc=fit.r0;
  // Position
  double phi1=atan2(pos.y()-yc,pos.x()-xc);
  double q_over_rc_tanl=FactorForSenseOfRotation*fit.h/(rc*fit.tanl);
  double dphi_s=(pos.z()-z)*q_over_rc_tanl;
  double dphi1=phi1-dphi_s;// was -
  double x=xc+rc*cos(dphi1);
  double y=yc+rc*sin(dphi1);
  pos.SetXYZ(x,y,z);

  dphi1*=-1.;
  if (fit.h<0) dphi1+=M_PI;

  // Momentum 
  double pt=0.003*fabs(Bz)*rc; 
  double px=pt*sin(dphi1);
  double py=pt*cos(dphi1);
  double pz=pt*fit.tanl;
  mom.SetXYZ(px,py,pz);
}

// Routine for updating the position and radius given an input position pos.
// If the circle from the track intersects the circle with a radius just outside
// the start counter, returns the position and momentum at the place where the 
// two circles intersect.  If the two circles do not intersect, returns the
// position at the doca to the beam line.  If the z position is far upstream 
// of the active volume for either case, places the position at z=0.
void DTrackCandidate_factory::UpdatePositionAndMomentum(DHelicalFit &fit,
							double Bz,
							const DVector3 &origin,
							DVector3 &pos,
							DVector3 &mom) const{
  // Get position at fixed radius with respect to the beam line
  if (GetPositionAndMomentum(fit,Bz,origin,pos,mom)!=NOERROR){      
    // Get position and momentum at doca to beam line
    GetPositionAndMomentum(fit,Bz,pos,mom);
  }
  // if the z-position is far away from the active volume of the detector,
  // place position at fixed z=0.
  if (pos.z()<0){ 
    GetPositionAndMomentum(0.,fit,Bz,pos,mom);
  }
}

// Redo the helical fit with additional hits
void DTrackCandidate_factory::DoRefit(DHelicalFit &fit,
				      const DTrackCandidate *fdccan,
				      vector<const DFDCPseudo*>&fdchits,
				      vector<const DCDCTrackHit*>&cdchits,
				      DVector3 &mom,DVector3 &pos
				      ){
  // Fake point at origin
  if (ADD_VERTEX_POINT){
    fit.AddHitXYZ(0.,0.,TARGET_Z,BEAM_VAR,BEAM_VAR,0.,true);
  }	
  // Add the cdc hits to use in the fit
  for (unsigned int k=0;k<cdchits.size();k++){	
    if (cdchits[k]->is_stereo==false){
      double cov=1.6*1.6/12.;  //guess
      DVector3 pos=cdchits[k]->wire->origin;
      fit.AddHitXYZ(pos.x(),pos.y(),pos.z(),cov,cov,0.,true);
    }
  }
  // Add the FDC hits
  double max_r=0.;
  for (unsigned int k=0;k<fdchits.size();k++){
    const DFDCPseudo *fdchit=fdchits[k];
    fit.AddHit(fdchit);
    if (fdchit->xy.Mod()>max_r) max_r=fdchit->xy.Mod();
  }
  if (fit.FitCircleRiemann(fdccan->rc)==NOERROR){
    for (unsigned int k=0;k<cdchits.size();k++){	
      if (cdchits[k]->is_stereo==true){
	fit.AddStereoHit(cdchits[k]->wire);
      }
    }
    // Initialize fit.tanl in case new line fit does not work
    fit.tanl=M_PI_2-atan(fdccan->dMomentum.Theta());
    fit.FitLineRiemann();
    
    // Estimate Bz
    double Bz=fabs(bfield->GetBz(pos.x(),pos.y(),pos.z()));
    
    // Check for extremely stiff tracks, some of which will have unphysical
    // momenta... try alternate circle fit
    bool tight_circle=fit.r0<0.5*max_r && max_r<10.0;
    double p=0.003*fit.r0*Bz/cos(atan(fit.tanl));
    if ((cdchits.size())>0?(p>3.):(p>10.||tight_circle)){
      if (ADD_VERTEX_POINT){
	fit.PruneHit(0); // prune fake point at center of target
      }
      fit.FitCircle();
      if (tight_circle){
	fit.FitLineRiemann();
      }
    }
    fit.FindSenseOfRotation();
    
    // Update position and momentum with new fit results
    DVector3 ref_pos=fdccan->dPosition;
    if (cdchits.size()>0) ref_pos=cdchits[0]->wire->origin;
    UpdatePositionAndMomentum(fit,Bz,ref_pos,pos,mom);   
  }
}

// Find intersection between CDC stereo wire and fit circle
void DTrackCandidate_factory::GetCDCIntersection(const DTrackCandidate *can,
						 const DCDCTrackHit *cdchit,
						 DVector3 &wirepos) const {
  DVector3 dir=(1./cdchit->wire->udir.z())*cdchit->wire->udir;
  double x0_minus_xc=wirepos.x()-can->xc;
  double y0_minus_yc=wirepos.y()-can->yc;
  double a=sqrt(can->rc*can->rc*dir.Perp2()
		-pow(x0_minus_xc*dir.y()-y0_minus_yc*dir.x(),2));
  double b= -x0_minus_xc*dir.x()-y0_minus_yc*dir.y();
  double c=1./dir.Perp2();
  double dz1=c*(b-a);
  double dz2=c*(b+a);
  if (fabs(dz1)<fabs(dz2)){
    wirepos+=dz1*dir;
  }
  else {
    wirepos+=dz2*dir;
  }
}

				    
