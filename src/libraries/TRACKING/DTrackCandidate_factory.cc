// $Id$
//
//    File: DTrackCandidate_factory.cc
// Created: Mon Jul 18 15:23:04 EDT 2005
// Creator: davidl (on Darwin wire129.jlab.org 7.8.0 powerpc)
//

/// Factory to match track candidates generated by the FDC- and CDC-specific 
/// track finding codes.
///
/// If a match is found, the code attempts to improve the track parameters by
/// redoing the Riemann Circle fit with the additional hits.  If an fdc 
/// candidate is matched to a cdc candidate, or several previously unused hits
/// are added to the track, the code attempts to place the "start" position 
/// parameters of the track at a radius just outside the start counter.

#include <cmath>
using namespace std;

#include "DTrackCandidate_factory.h"

#include <JANA/JEvent.h>
#include <JANA/Calibrations/JCalibrationManager.h>
#include <JANA/Services/JLockService.h>
#include "DANA/DGeometryManager.h"
#include "HDGEOMETRY/DGeometry.h"
#include <CDC/DCDCTrackHit.h>

#include "START_COUNTER/DSCHit.h"
#include <TRACKING/DHoughFind.h>

#include <TROOT.h>
#include <TH2F.h>
#include <TMath.h>

#define CUT 10.
#define RADIUS_CUT 50.0
#define BEAM_VAR 1. // cm^2
#define EPS 0.001

//------------------
// cdc_fdc_match
//------------------
inline bool cdc_fdc_match(double p_fdc,double p_cdc,double dist){
  //double frac=fabs(1.-p_cdc/p_fdc);
  //double frac2=fabs(1.-p_fdc/p_cdc);
  double p=p_fdc;
  if (p_cdc <p ) p=p_cdc;
  if (dist<10. && dist <4.+1.75/p
      //&& (frac<0.5 || frac2<0.5)
      ) return true;
  return false;
}

//------------------
// SegmentSortByLayerincreasing
//------------------
inline bool SegmentSortByLayerincreasing(const DFDCSegment* const &segment1, const DFDCSegment* const &segment2) {
	// Compare DFDCSegment->DFDCPseudo[0]->DFDCWire->layer
	int layer1 = 100; // defaults just in case there is a segment with no hits
	int layer2 = 100;
	
	if(segment1->hits.size()>0)layer1=segment1->hits[0]->wire->layer;
	if(segment2->hits.size()>0)layer2=segment2->hits[0]->wire->layer;

	return layer1 < layer2;
}

//------------------
// CDCHitSortByLayerincreasing
//------------------
inline bool CDCHitSortByLayerincreasing(const DCDCTrackHit* const &hit1, const DCDCTrackHit* const &hit2) {
	// Used to sort CDC hits by layer (ring) with innermost layer hits first

	// if same ring, sort by wire number
	if(hit1->wire->ring == hit2->wire->ring)
	{
		if(hit1->wire->straw == hit2->wire->straw)
			return (hit1->dE > hit2->dE);
		return hit1->wire->straw < hit2->wire->straw;
	}

	return hit1->wire->ring < hit2->wire->ring;
}

//------------------
// FDCHitSortByLayerincreasing
//------------------
inline bool FDCHitSortByLayerincreasing(const DFDCPseudo* const &hit1, const DFDCPseudo* const &hit2) {
  // Used to sort FDC hits by layer with most upstream layer hits first  
  // if same layer, sort by wire number
  if(hit1->wire->layer == hit2->wire->layer)
    {
      if(hit1->wire->wire == hit2->wire->wire)
	return (hit1->dE > hit2->dE);
      return (hit1->wire->wire < hit2->wire->wire);
    }
  
  return hit1->wire->layer < hit2->wire->layer;
}

//------------------
// Init
//------------------
void DTrackCandidate_factory::Init()
{
	MAX_NUM_TRACK_CANDIDATES = 20;
}

//------------------
// BeginRun
//------------------
void DTrackCandidate_factory::BeginRun(const std::shared_ptr<const JEvent>& event){

  auto run_number = event->GetRunNumber();
  auto app = GetApplication();
  auto root_lock = app->GetService<JLockService>();
  auto jcalib = app->GetService<JCalibrationManager>()->GetJCalibration(run_number);
  auto geo_manager = app->GetService<DGeometryManager>();
  auto dgeom = geo_manager->GetDGeometry(run_number);
  bfield = geo_manager->GetBfield(run_number);

  FactorForSenseOfRotation=(bfield->GetBz(0.,0.,65.)>0.)?-1.:1.;

  // Get start counter geometry;
  dgeom->GetStartCounterGeom(sc_pos,sc_norm);

  dIsNoFieldFlag = (dynamic_cast<const DMagneticFieldMapNoField*>(bfield) != NULL);
  if(dIsNoFieldFlag)
  {
    //Setting this flag makes it so that JANA does not delete the objects in mData.  This factory will manage this memory.
      //This is all of these pointers are just copied from the "StraightLine" factory, and should not be re-deleted.
    SetFactoryFlag(NOT_OBJECT_OWNER);
  }
  else
    ClearFactoryFlag(NOT_OBJECT_OWNER); //This factory will create it's own objects.

  // Get the position of the exit of the CDC endplate from DGeometry
  double endplate_z,endplate_dz,endplate_rmin;
  dgeom->GetCDCEndplate(endplate_z,endplate_dz,endplate_rmin,endplate_rmax);
  cdc_endplate.SetZ(endplate_z+endplate_dz);

  dParticleID = NULL;
  event->GetSingle(dParticleID);

  map<string, double> targetparms;
  if (jcalib->Get("TARGET/target_parms",targetparms)==false){
    TARGET_Z = targetparms["TARGET_Z_POSITION"];
   }
  else{
    dgeom->GetTargetZ(TARGET_Z);
  }

   // Initialize the stepper
  stepper=new DMagneticFieldStepper(bfield);
  stepper->SetStepSize(1.0);

  DEBUG_HISTS=false;
  app->SetDefaultParameter("TRKFIND:DEBUG_HISTS",DEBUG_HISTS);

  if(DEBUG_HISTS){
    root_lock->RootWriteLock();
    /*
    match_center_dist2=(TH2F*)gROOT->FindObject("match_center_dist2");
    if (!match_center_dist2){
      match_center_dist2=new TH2F("match_center_dist2","larger radius vs matching distance squared between two circle centers",100,0,100.,100,0,100);
      match_center_dist2->SetYTitle("r_{c} [cm]");
      match_center_dist2->SetXTitle("(#Deltad)^{2} [cm^{2}]");
    }
    */
    match_dist=(TH2F*)gROOT->FindObject("match_dist");
    if (!match_dist){
      match_dist=new TH2F("match_dist","Matching distance",
			  120,0.,60.,500,0,25.);
      match_dist->SetXTitle("r (cm)");
      match_dist->SetYTitle("#Deltar (cm)");
    }
    match_dist_vs_p=(TH2F*)gROOT->FindObject("match_dist_vs_p");
    if (!match_dist_vs_p) {
      match_dist_vs_p=new TH2F("match_dist_vs_p","Matching distance vs p",
			       50,0.,7.,100,0,25.);
      match_dist_vs_p->SetYTitle("#Deltar (cm)");
      match_dist_vs_p->SetXTitle("p (GeV/c)");
    }
      root_lock->RootUnLock();
  }

  app->SetDefaultParameter("TRKFIND:MAX_NUM_TRACK_CANDIDATES", MAX_NUM_TRACK_CANDIDATES); 

  //  MIN_NUM_HITS=6;
  //app->SetDefaultParameter("TRKFIND:MIN_NUM_HITS", MIN_NUM_HITS);
  
  DEBUG_LEVEL=0;
  app->SetDefaultParameter("TRKFIND:DEBUG_LEVEL", DEBUG_LEVEL);

  ADD_VERTEX_POINT=true;
  app->SetDefaultParameter("TRKFIND:ADD_VERTEX_POINT", ADD_VERTEX_POINT);
   
  return;
}

//------------------
// EndRun
//------------------
void DTrackCandidate_factory::EndRun()
{
  if (stepper) {
    delete stepper;
    stepper = nullptr;
  }
}

//------------------
// EndRun
//------------------
void DTrackCandidate_factory::Finish()
{
  if (stepper) {
    delete stepper;
    stepper = nullptr;
  }
}



//------------------
// Process
//------------------
void DTrackCandidate_factory::Process(const std::shared_ptr<const JEvent>& event)
{
  if(dIsNoFieldFlag)
  {
    //Clear previous objects: //JANA doesn't do it because NOT_OBJECT_OWNER was set
	  //It DID delete them though, in the "StraightLine" factory
    mData.clear();

    vector<const DTrackCandidate*> locStraightLineCandidates;
    event->Get(locStraightLineCandidates, "StraightLine");
    for(size_t loc_i = 0; loc_i < locStraightLineCandidates.size(); ++loc_i)
      mData.push_back(const_cast<DTrackCandidate*>(locStraightLineCandidates[loc_i]));
    return;
  }
  
   // Start counter hits
  vector<const DSCHit *>schits;
  event->Get(schits);


  // Clear private vectors
  cdctrackcandidates.clear();
  fdctrackcandidates.clear();
  trackcandidates.clear();
  mycdchits.clear();

  // Get the track candidates from the CDC and FDC candidate finders
  event->Get(cdctrackcandidates, "CDC");
  event->Get(fdctrackcandidates, "FDCCathodes");

  // List of cdc hits
  event->Get(mycdchits);

  // Vectors for keeping track of cdc matches and projections to the endplate
  vector<unsigned int> cdc_forward_ids;
  vector<unsigned int> cdc_backward_ids;
  vector<DVector3> cdc_endplate_projections;
 
  // Vector to keep track of cdc hits used in candidates
  vector<unsigned int>used_cdc_hits(mycdchits.size());

  // vector to keep track of the matching status of each fdc candidate
  vector<int>fdc_matches(fdctrackcandidates.size());
  vector<int>cdc_matches(cdctrackcandidates.size());

  // Loop over fdc candidates looking for matches with cdc candidates
  for (unsigned int i=0;i<fdctrackcandidates.size();i++){
    if (fdc_matches[i]) continue;

    // FDC candidate not already used -- let's proceed.
    const DTrackCandidate *fdccan=fdctrackcandidates[i];
    if (fdccan->FirstPackage>0) continue;

    // Loop over cdc candidates
    for (unsigned int j=0;j<cdctrackcandidates.size();j++){
      if (cdc_matches[j]) continue;
	  
      // CDC candidate not already used -- let's proceed.
      const DTrackCandidate *cdccan=cdctrackcandidates[j];
      if (fdccan->dPosition.x()*cdccan->dPosition.x()<0) continue;
      if (fdccan->dPosition.y()*cdccan->dPosition.y()<0) continue;
      if (fdccan->dPosition.Perp2()<cdccan->dPosition.Perp2()) continue;
      
      vector<const DCDCTrackHit*>cdchits=cdccan->Get<DCDCTrackHit>();
      vector<pair<unsigned int,DVector3>>cdcXYZ;
      // loop over the cdc hits and count hits that agree with a projection of 
      // the helix into the cdc
      for (unsigned int m=0;m<cdchits.size();m++){
	double variance=1.6*1.6/12.;

	DVector3 wirepos=cdchits[m]->wire->origin;	
	if (cdchits[m]->is_stereo){
	  DVector3 dir=(1./cdchits[m]->wire->udir.z())*cdchits[m]->wire->udir;
	  double x0_minus_xc=wirepos.x()-cdccan->xc;
	  double y0_minus_yc=wirepos.y()-cdccan->yc;
	  double a=sqrt(cdccan->rc*cdccan->rc*dir.Perp2()
			-pow(x0_minus_xc*dir.y()-y0_minus_yc*dir.x(),2));
	  double b= -x0_minus_xc*dir.x()-y0_minus_yc*dir.y();
	  double c=1./dir.Perp2();
	  double dz1=c*(b-a);
	  double dz2=c*(b+a);
	  if (fabs(dz1)<fabs(dz2)){
	    wirepos+=dz1*dir;
	  }
	  else {
	    wirepos+=dz2*dir;
	  }
	}
	
	// Look for a match
	if (wirepos.z()>167.) break;
	double dr=sqrt(pow(wirepos.x()-fdccan->xc,2)
		       +pow(wirepos.y()-fdccan->yc,2))-fdccan->rc;
	double prob=TMath::Prob(dr*dr/variance,1);
	
	if (prob>0.01) cdcXYZ.push_back(make_pair(m,wirepos));
      }
      if (cdcXYZ.size()>=3){
	// Create a new DHelicalFit object for fitting combined data
	DHelicalFit fit;	
	 // Add the cdc hits to use in the fit 
	for (unsigned int k=0;k<cdcXYZ.size();k++){	
	  double cov=0.213;  //guess
	  fit.AddHitXYZ(cdcXYZ[k].second.x(),cdcXYZ[k].second.y(),
			cdcXYZ[k].second.z(),cov,cov,0.,
			!cdchits[cdcXYZ[k].first]->is_stereo);
	}
	// Add the FDC hits
	vector<const DFDCSegment *>segments=fdccan->Get<DFDCSegment>();
	for (unsigned int k=0;k<segments.size();k++){
	  for (unsigned int n=0;n<segments[k]->hits.size();n++){
	    const DFDCPseudo *fdchit=segments[k]->hits[n];
	    fit.AddHit(fdchit);
	  }
	}
	if (fit.FitTrackRiemann(fdccan->rc)==NOERROR){
	  // Estimate Bz
	  DVector3 pos=fdccan->dPosition;
	  double Bz=fabs(bfield->GetBz(pos.x(),pos.y(),pos.z()));
	  // Update position and momentum with new fit results
	  DVector3 mom;
	  UpdatePositionAndMomentum(fit,Bz,cdchits[0]->wire->origin,pos,mom);

	  // Create new track candidate object 
	  DTrackCandidate *can = new DTrackCandidate;
	  can->used_cdc_indexes=cdccan->used_cdc_indexes;
	  // circle parameters
	  can->rc=fit.r0;
	  can->xc=fit.x0;
	  can->yc=fit.y0;
	  
	  // Add cdc and fdc hits to the track as associated objects
	  for (unsigned int m=0;m<segments.size();m++){
	    for (unsigned int n=0;n<segments[m]->hits.size();n++){
	      can->AddAssociatedObject(segments[m]->hits[n]);
	    }
	  }
	  can->LastPackage=fdccan->LastPackage;
	  for (unsigned int n=0;n<cdcXYZ.size();n++){
	    can->AddAssociatedObject(cdchits[cdcXYZ[n].first]); 
	  }
	  
	  can->chisq=fit.chisq;
	  can->Ndof=fit.ndof;
	  
	  can->dCharge=FactorForSenseOfRotation*fit.h;
	  can->dMomentum=mom;
	  can->dPosition=pos;
	  
	  Insert(can);

	  fdc_matches[i]=1;
	  cdc_matches[j]=1;
	}
      }
    }
  }
  for (unsigned int i=0;i<mData.size();i++){
    for (unsigned int j=0;j<fdctrackcandidates.size();j++){
      if (fdc_matches[j]) continue;

      const DTrackCandidate *fdccan=fdctrackcandidates[j];
      if (fdccan->FirstPackage==mData[i]->LastPackage+1){
	cout << "Packages " << mData[i]->LastPackage << " "
	     << fdccan->FirstPackage << endl;
      }
    }
  }

  // Add unmatched cdc and fdc candidates to the output list
  for (unsigned int i=0;i<fdctrackcandidates.size();i++){
    if (fdc_matches[i]) continue;

    // Create new track candidate object 
    DTrackCandidate *can = new DTrackCandidate;
    const DTrackCandidate *fdccan=fdctrackcandidates[i];
    
     // circle parameters
    can->rc=fdccan->rc;
    can->xc=fdccan->xc;
    can->yc=fdccan->yc;
    
    can->dMomentum=fdccan->dMomentum;
    can->dPosition=fdccan->dPosition;
    can->dCharge=fdccan->dCharge;
    
    can->chisq=fdccan->chisq;
    can->Ndof=fdccan->Ndof;

    vector<const DFDCSegment*>segments=fdccan->Get<DFDCSegment>();
    for (unsigned int m=0;m<segments.size();m++){		  
      for (unsigned int n=0;n<segments[m]->hits.size();n++){
	const DFDCPseudo *fdchit=segments[m]->hits[n];
	can->AddAssociatedObject(fdchit);
      }
    }

    Insert(can);
  }
  for (unsigned int i=0;i<cdctrackcandidates.size();i++){
    if (cdc_matches[i]) continue;

    // Create new track candidate object 
    DTrackCandidate *can = new DTrackCandidate;
    const DTrackCandidate *cdccan=cdctrackcandidates[i];
    
     // circle parameters
    can->rc=cdccan->rc;
    can->xc=cdccan->xc;
    can->yc=cdccan->yc;
    
    can->dMomentum=cdccan->dMomentum;
    can->dPosition=cdccan->dPosition;
    can->dCharge=cdccan->dCharge;
    
    can->chisq=cdccan->chisq;
    can->Ndof=cdccan->Ndof;

    vector<const DCDCTrackHit *>cdchits=cdccan->Get<DCDCTrackHit>();
    for (unsigned int n=0;n<cdchits.size();n++){
      can->AddAssociatedObject(cdchits[n]); 
    }

    Insert(can);
  }
  
  // Limit the number of candidates to pass to the track fitting stage
  if((int(mData.size()) > MAX_NUM_TRACK_CANDIDATES) && (MAX_NUM_TRACK_CANDIDATES >= 0)){
    if (DEBUG_LEVEL>0) _DBG_ << "Number of candidates = " << mData.size()
			     << " > " <<  MAX_NUM_TRACK_CANDIDATES
			     << " --- skipping track fitting! " << endl;
    for(size_t loc_i = 0; loc_i < mData.size(); ++loc_i)
      delete mData[loc_i];
    mData.clear();
  }
}

// Obtain position and momentum at the exit of a given package using the 
// helical track model.
void DTrackCandidate_factory::GetPositionAndMomentum(const DFDCSegment *segment,
						     DVector3 &pos, 
						     DVector3 &mom) const{
  // Position of track segment at last hit plane of package
  double x=segment->xc+segment->rc*cos(segment->Phi1);
  double y=segment->yc+segment->rc*sin(segment->Phi1);
  double z=segment->hits[0]->wire->origin.z();

  // Track parameters
  //double kappa=segment->q/(2.*segment->rc);
  double phi0=segment->phi0;
  double tanl=segment->tanl;
  double z0=segment->z_vertex;

  // Useful intermediate variables
  double cosp=cos(phi0);
  double sinp=sin(phi0);
  double sperp=(z-z0)/tanl;
  //double twoks=2.*kappa*sperp;
  double twoks=FactorForSenseOfRotation*segment->q*sperp/segment->rc;
  double sin2ks=sin(twoks);
  double cos2ks=cos(twoks); 

  // Get Bfield
  double B=fabs(bfield->GetBz(x,y,z));

  // Momentum
  double pt=0.003*B*segment->rc;
  double px=pt*(cosp*cos2ks-sinp*sin2ks);
  double py=pt*(sinp*cos2ks+cosp*sin2ks);
  double pz=pt*tanl;

  pos.SetXYZ(x,y,z);
  mom.SetXYZ(px,py,pz);
}

// Get position and momentum at doca to beam line
void DTrackCandidate_factory::GetPositionAndMomentum(const DHelicalFit &fit,
						     double Bz,
						     DVector3 &pos,
						     DVector3 &mom) const{
  // Find position at doca to beam line
  double phi0=atan2(-fit.x0,fit.y0);
  if (fit.h<0) phi0+=M_PI;
  double sinphi0=sin(phi0);
  double sign=(sinphi0>0)?1.:-1.;
  if (fabs(sinphi0)<1e-8) sinphi0=sign*1e-8;
  double cosphi0=cos(phi0);
  double D=FactorForSenseOfRotation*fit.h*fit.r0-fit.x0/sinphi0;
  double x=-D*sinphi0;
  double y=D*cosphi0;
  double dx=pos.x()-x;
  double dy=pos.y()-y;
  double ratio=sqrt(dx*dx+dy*dy)/(2.*fit.r0);
  double phi_s=(ratio<1.)?2.*asin(ratio):M_PI;
  double newz=pos.z()-phi_s*fit.tanl*fit.r0;
  pos.SetXYZ(x,y,newz);
    
  // momentum at POCA to beam line
  double pt=0.003*Bz*fit.r0;
  mom.SetXYZ(pt*cosphi0,pt*sinphi0,pt*fit.tanl);
}

// Get the position and momentum at a fixed radius from the beam line
jerror_t DTrackCandidate_factory::GetPositionAndMomentum(DHelicalFit &fit,
							 double Bz,
							 const DVector3 &origin,
							 DVector3 &pos,
							 DVector3 &mom) const{
  double r2=65.0;
  double xc=fit.x0;
  double yc=fit.y0;
  double rc=fit.r0;
  double tworc=2.*rc;
  double rc2=rc*rc;
  double xc2=xc*xc;
  double yc2=yc*yc;
  double xc2_plus_yc2=xc2+yc2;
  double a=(r2-xc2_plus_yc2-rc2)/tworc;
  double b=xc2_plus_yc2-a*a;
  if (b<0){
    // We did not find an intersection between the two circles, so return 
    // an error.  The values of mom and pos are not changed. 
    return VALUE_OUT_OF_RANGE;
  }

  double temp1=yc*sqrt(b);
  double temp2=xc*a;
  double cosphi_plus=(temp2+temp1)/xc2_plus_yc2;
  double cosphi_minus=(temp2-temp1)/xc2_plus_yc2;

  // Direction tangent and transverse momentum
  double tanl=fit.tanl;
  double pt=0.003*Bz*rc;

  double phi_plus=acos(cosphi_plus);
  double phi_minus=acos(cosphi_minus);
  double x_plus=xc+rc*cosphi_plus;
  double x_minus=xc+rc*cosphi_minus;
  double y_plus=yc+rc*sin(phi_plus);
  double y_minus=yc+rc*sin(phi_minus);

  // if the resulting radial position on the circle from the fit does not agree
  // with the radius to which we are matching, we have the wrong sign for phi+ 
  // or phi-
  double r2_plus=x_plus*x_plus+y_plus*y_plus;
  double r2_minus=x_minus*x_minus+y_minus*y_minus;  
  if (fabs(r2-r2_plus)>EPS){
    phi_plus*=-1.;
    y_plus=yc+rc*sin(phi_plus);
  }
  if (fabs(r2-r2_minus)>EPS){
    phi_minus*=-1.;
    y_minus=yc+rc*sin(phi_minus);
  }

  // Choose phi- or phi+ depending on proximity to one of the cdc hits
  double xwire=origin.x();
  double ywire=origin.y();
  double dx=x_minus-xwire;
  double dy=y_minus-ywire;
  double d2_minus=dx*dx+dy*dy;
  dx=x_plus-xwire;
  dy=y_plus-ywire;
  double d2_plus=dx*dx+dy*dy;
 
  DVector3 pos0(pos); // save the input position, for use in finding z
  if (d2_plus>d2_minus){
    fit.h=-1.;
    phi_minus=M_PI-phi_minus;
    pos.SetXYZ(x_minus,y_minus,0.); // z will be filled later
    mom.SetXYZ(pt*sin(phi_minus),pt*cos(phi_minus),pt*tanl);
  }
  else{
    fit.h=1.;
    phi_plus*=-1.;   
    pos.SetXYZ(x_plus,y_plus,0.); // z will be filled later
    mom.SetXYZ(pt*sin(phi_plus),pt*cos(phi_plus),pt*tanl);
  }
  // Next find the z-position corresponding to the new (x,y) position
  double ratio=(pos0-pos).Perp()/tworc;
  double sperp=(ratio<1.)?tworc*asin(ratio):tworc*M_PI_2;
  pos.SetZ(pos0.z()-sperp*tanl);
  return NOERROR;
}

// Routine to return momentum and position given the helical parameters and the
// z-component of the magnetic field
void
DTrackCandidate_factory::GetPositionAndMomentum(double z,const DHelicalFit &fit,
						double Bz,DVector3 &pos,
						DVector3 &mom) const{
  double xc=fit.x0;
  double yc=fit.y0;
  double rc=fit.r0;
  // Position
  double phi1=atan2(pos.y()-yc,pos.x()-xc);
  double q_over_rc_tanl=FactorForSenseOfRotation*fit.h/(rc*fit.tanl);
  double dphi_s=(pos.z()-z)*q_over_rc_tanl;
  double dphi1=phi1-dphi_s;// was -
  double x=xc+rc*cos(dphi1);
  double y=yc+rc*sin(dphi1);
  pos.SetXYZ(x,y,z);

  dphi1*=-1.;
  if (fit.h<0) dphi1+=M_PI;

  // Momentum 
  double pt=0.003*fabs(Bz)*rc; 
  double px=pt*sin(dphi1);
  double py=pt*cos(dphi1);
  double pz=pt*fit.tanl;
  mom.SetXYZ(px,py,pz);
}

// Routine for updating the position and radius given an input position pos.
// If the circle from the track intersects the circle with a radius just outside
// the start counter, returns the position and momentum at the place where the 
// two circles intersect.  If the two circles do not intersect, returns the
// position at the doca to the beam line.  If the z position is far upstream 
// of the active volume for either case, places the position at z=0.
void DTrackCandidate_factory::UpdatePositionAndMomentum(DHelicalFit &fit,
							double Bz,
							const DVector3 &origin,
							DVector3 &pos,
							DVector3 &mom) const{
  // Get position at fixed radius with respect to the beam line
  if (GetPositionAndMomentum(fit,Bz,origin,pos,mom)!=NOERROR){      
    // Get position and momentum at doca to beam line
    GetPositionAndMomentum(fit,Bz,pos,mom);
  }
  // if the z-position is far away from the active volume of the detector,
  // place position at fixed z=0.
  if (pos.z()<0){ 
    GetPositionAndMomentum(0.,fit,Bz,pos,mom);
  }
}



