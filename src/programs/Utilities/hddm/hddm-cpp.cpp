/*
 *  hddm-cpp :	tool that reads in a HDDM document (Hall D Data Model)
 *		and writes a c++ class library that expresses the model
 *		in c++ classes.  It also generates input/output methods
 *		for serializing/deserializing these classes in a form
 *		suitable for passing over a network or storing on disk.
 *
 *  author: richard.t.jones at uconn.edu
 *  version: January 25, 2006 - original release.
 *           January 13, 2012 - added support for compression through
 *                              the xstream zip and bzip2 facilities.
 *           June 4, 2016     - added reposition support for random
 *                              access to hddm streams, including
 *                              compressed streams.
 *           October 10, 2020 - introduced support for reading and
 *                              writing of hddm streams to HDF5 files.
 *
 *  Version 1.4 - Richard Jones, February 10, 2021.
 *  - Modified to be able to accept a hddm file as a valid hddm template.
 *    This simplifies the documentation by eliminating the false distinction
 *    between a hddm template and the text header that appears at the top of
 *    every hddm file. It also gets rid of the unnecessary step of having
 *    to delete the binary data following the header in a hddm file before
 *    it can be used as a template.
 *
 *  Programmer's Notes:
 *  -------------------
 * 1. The HDDM specification describes data files using xml.  For
 *    information about the contents and structure of HDDM documents
 *    see the web page that describes the data model.
 *
 * 2. Access by hddm-cpp to the xml source is through the industry-
 *    standard Document Object Model (DOM) interface.
 *
 * 3. The code has been tested with the xerces-c DOM implementation from
 *    Apache, and is intended to be used with the xerces-c library.
 *
 * 4. Output is sent to <filename>.hpp and <filename>++.cpp where <filename>
 *    is by default "hddm_X" and can be changed with the -o option, where
 *    X is the user-defined HDDM class string defined in the HDDM tag.
 *
 * 5. As a by-product of using the DOM parser to access the xml source,
 *    hddm-cpp verifies the source for well-formedness.  Therefore it may
 *    also be used to check the xml data model document.
 *
 *
 *  Implementation Notes:
 *  ---------------------
 * 1. The binary stream consists of the hddm data model in the form
 *    of a well-formed xml header, followed by binary data.
 *
 * 2. The binary data consist of a sequence of event records, which are
 *    repetitions of the basic data model in a serial representation.
 *
 * 3. Each element is output to the stream in the order it appears in
 *    the data model, prefixed by an exclusive byte count.
 *
 * 4. Any c++ application compiled with the hddm header file that is
 *    generated by hddm-cpp is able to read any hddm binary file that
 *    was written using the same hddm class, ie. the <HDDM class="x">
 *    document tags must be a non-colliding set (see matching rules).
 *
 * 5. The input/output features of the class library produced by hddm-cpp
 *    are implemented on top of the "xstream" binary i/o class by Claudio
 *    Valente which provides serialization/deserialization of binary data
 *    using network byte-ordering (RFC-1832), compression/decompression,
 *    and error checking capability used to make the hddm i/o facility
 *    flexible and robust.
 *
 * 6. The matching rules between the built-in data model and the data
 *    found in an arbitrary input file are as follows:
 *    a) The attribute list for any given tag must be identical in content
 *       and order wherever it appears, otherwise there is a collision.
 *    b) The content list for any given tag must be internally consistent
 *       within each model, but there are no requirements for agreement
 *       between the classes and the binary stream models.  Only the
 *       contents which appear in both models will be unpacked, however.
 */

#include "VersionConfig.hpp"
#include "XString.hpp"
#include "XParsers.hpp"
#include <xercesc/util/XMLUri.hpp>

#include <particleType.h>
#include <errno.h>
#include <unistd.h>

#include <string>
#include <vector>
#include <map>
#include <fstream>
#include <sstream>

#define X(str) XString(str).unicode_str()
#define S(str) str.c_str()

using namespace xercesc;

XString classPrefix;

void usage()
{
   std::cerr
        << "\nUsage:\n"
        << "    hddm-cpp [-v | -o <filename>] {HDDM file}\n\n"
        << "Options:\n"
        <<  "    -v			validate only\n"
        <<  "    -o <filename>	write to <filename>.hpp, <filename>++.cpp"
        << "Version: " << HDDM_VERSION_MAJOR << "." << HDDM_VERSION_MINOR
        << std::endl;
}

std::string guessType(const std::string &literal);
Particle_t lookupParticle(const std::string &name);

class XtString : public XString
{
/* XString class with a few extra methods for creating type
 * strings that are useful in creating class names
 */
 public:
   XtString() {};
   XtString(const char* s): XString(s) {};
   XtString(const XMLCh* p): XString(p) {};
   XtString(const std::string& s): XString(s) {};
   XtString(const XString& x): XString(x) {};
   XtString(const XtString& t): XString((XString&)t) {};
   ~XtString() {};

   XtString plural();
   XtString simpleType();
   XtString listType();
   XtString linkType();
};

class CodeBuilder
{
/* The methods in this class are used to write the c++ code
 * that implements the hddm class library.
 */
 public:
   std::ofstream hFile;
   std::ofstream cFile;

   CodeBuilder() {};
   ~CodeBuilder() {};

   void checkConsistency(DOMElement* el, DOMElement* elref);
   void writeClassdef(DOMElement* el);
   void writeClassimp(DOMElement* el);
   void constructDocument(DOMElement* el);
   void constructGroup(DOMElement* el);
   void constructIOstreams(DOMElement* el);
   void constructMethods(DOMElement* el);
   void constructStreamers(DOMElement* el);
   void writeStreamers(DOMElement* el);

 private:
   std::vector<DOMElement*> tagList;
   typedef std::vector<DOMNode*> parentList_t;
   typedef std::map<const XtString,parentList_t> parentTable_t;
   parentList_t parentList;
   parentTable_t parents;
   parentTable_t children;
   int element_in_list(XtString &name, parentList_t list);
};


int main(int argC, char* argV[])
{
   try
   {
      XMLPlatformUtils::Initialize();
   }
   catch (const XMLException* toCatch)
   {
      XtString msg(toCatch->getMessage());
      std::cerr
           << "hddm-cpp: Error during initialization! :\n"
           << msg << std::endl;
      return 1;
   }

   if (argC < 2)
   {
      usage();
      return 1;
   }
   else if ((argC == 2) && (strcmp(argV[1], "-?") == 0))
   {
      usage();
      return 2;
   }

   XtString xmlFile;
   XtString hFilename;
   bool verifyOnly = false;
   int argInd;
   for (argInd = 1; argInd < argC; argInd++)
   {
      if (argV[argInd][0] != '-')
      {
         break;
      }
      if (strcmp(argV[argInd],"-v") == 0)
      {
         verifyOnly = true;
      }
      else if (strcmp(argV[argInd],"-o") == 0)
      {
         hFilename = XtString(argV[++argInd]);
      }
      else
      {
         std::cerr
              << "Unknown option \'" << argV[argInd]
              << "\', ignoring it\n" << std::endl;
      }
   }

   if (argInd != argC - 1)
   {
      usage();
      return 1;
   }
   xmlFile = XtString(argV[argInd]);
   std::ifstream ifs(xmlFile.c_str());
   if (!ifs.good())
   {
      std::cerr
           << "hddm-cpp: Error opening hddm template " << xmlFile << std::endl;
      exit(1);
   }
   std::ostringstream tmpFileStr;
   tmpFileStr << "tmp" << getpid();
   std::ofstream ofs(tmpFileStr.str().c_str());
   if (! ofs.is_open())
   {
      std::cerr
           << "hddm-cpp: Error opening temp file " << tmpFileStr.str() << std::endl;
      exit(2);
   }

   XString xmlPreamble("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
   XString xmlHeader;
   XString line;
   while (getline(ifs,line))
   {
      if (line.find("<?xml") != line.npos)
      {
         xmlPreamble = line + "\n";
      }
      else if (line.find("<!DOCTYPE HDDM>") != line.npos)
      {
         xmlPreamble += line + "\n";
      }
      else if (line.size() == 0)
      {
         xmlPreamble += "\n";
      }
      else if (line.find("<HDDM ") != line.npos)
      {
         xmlHeader = line + "\n";
         ofs << xmlPreamble << line;
         break;
      }
      else
      {
         std::cerr
              << "hddm-cpp: Template does not contain valid hddm header"
              << std::endl;
         exit(1);
      }
   }
   if (xmlHeader.size() == 0)
   {
      std::cerr
           << "hddm-cpp: Error reading from hddm template " << xmlFile 
           << std::endl;
      exit(1);
   }
   while (getline(ifs,line))
   {
      ofs << line;
      if (line == "</HDDM>")
      {
         break;
      }
   }
   ofs.close();
   ifs.close();

#if defined OLD_STYLE_XERCES_PARSER
   DOMDocument* document = parseInputDocument(tmpFileStr.str().c_str(),false);
#else
   DOMDocument* document = buildDOMDocument(tmpFileStr.str().c_str(),false);
#endif
   if (document == 0)
   {
      std::cerr
           << "hddm-cpp : Error parsing HDDM document, "
           << "cannot continue" << std::endl;
      return 1;
   }
   unlink(tmpFileStr.str().c_str());

   DOMElement* rootEl = document->getDocumentElement();
   XtString rootS(rootEl->getTagName());
   if (rootS != "HDDM")
   {
      std::cerr
           << "hddm-cpp error: root element of input document is "
           << "\"" << rootS << "\", expected \"HDDM\""
           << std::endl;
      return 1;
   }

   XtString classS(rootEl->getAttribute(X("class")));
   classPrefix = classS;

   XtString hname;
   if (verifyOnly)
   {
      hname = "/dev/null";
   }
   else if (hFilename.size())
   {
      hname = hFilename + ".hpp";
   }
   else
   {
      hname = "hddm_" + classPrefix + ".hpp";
   }

   CodeBuilder builder;
   builder.hFile.open(hname.c_str());
   if (! builder.hFile.is_open())
   {
      std::cerr
           << "hddm-cpp error: unable to open output file "
           << hname << std::endl;
      return 1;
   }

   XtString cname;
   if (verifyOnly)
   {
      cname = "/dev/null";
   }
   else if (hFilename.size())
   {
      cname = hFilename + "++.cpp";
   }
   else
   {
      cname = "hddm_" + classPrefix + "++.cpp";
   }

   builder.cFile.open(cname.c_str());
   if (! builder.cFile.is_open())
   {
      std::cerr
           << "hddm-cpp error: unable to open output file "
           << cname << std::endl;
      return 1;
   }

   builder.hFile <<
   "/*\n"
   " * hddm_" << classPrefix << ".hpp - DO NOT EDIT THIS FILE\n"
   " *\n"
   " * This file was generated automatically by hddm-cpp from the file\n"
   << " * " << xmlFile << std::endl <<
   "\n"
   " * This header file defines the c++ classes that hold the data\n"
   " * described in the data model (from " << xmlFile << "). \n"
   " *\n"
   " * The hddm data model tool set was written by\n"
   " * Richard Jones, University of Connecticut.\n"
   " *\n"
   " * For more information see the documentation at\n"
   " * http://github.com/rjones30/HDDM\n"
   " *\n"
   " */\n"
   "\n"
   "#ifndef SAW_" << classPrefix << "_HDDM\n"
   "#define SAW_" << classPrefix << "_HDDM\n"
   "\n"
   "#include <map>\n"
   "#include <list>\n"
   "#include <deque>\n"
   "#include <vector>\n"
   "#include <string>\n"
   "#include <atomic>\n"
   "#include <sstream>\n"
   "#include <stdexcept>\n"
   "#include <streambuf>\n"
   "#include <xstream/z.h>\n"
   "#include <xstream/bz.h>\n"
   "#include <xstream/xdr.h>\n"
   "#include <xstream/digest.h>\n"
   "#include <particleType.h>\n"
   "#include <pthread.h>\n"
   "#include <assert.h>\n"
   "#include <climits>\n"
   "\n"
   "#ifdef HDF5_SUPPORT\n"
   "#include <H5Fpublic.h>\n"
   "#include <H5Tpublic.h>\n"
   "#include <H5Ppublic.h>\n"
   "#include <H5Spublic.h>\n"
   "#include <H5Dpublic.h>\n"
   "#include <H5LTpublic.h>\n"
   "#endif\n"
   "\n"
   "#define MY_SETUP thread_private_data *my_private = lookup_private_data();\n"
   "#define MY(VAR) my_private->m_ ## VAR\n"
   "\n"
   "namespace hddm_" << classPrefix << " {\n"
   "\n"
   "const int k_default_status = 0x0;\n"
   "const int k_bits_compression = 0xf0;\n"
   "const int k_no_compression = 0x00;\n"
   "const int k_z_compression = 0x10;\n"
   "const int k_bz2_compression = 0x20;\n"
   "const int k_bits_integrity = 0x0f;\n"
   "const int k_no_integrity = 0x00;\n"
   "const int k_crc32_integrity = 0x01;\n"
   "const int k_bits_randomaccess = 0xf00;\n"
   "const int k_can_reposition = 0x100;\n"
   "\n"
   "enum hddm_type {\n"
   "   k_hddm_unknown,\n"
   "   k_hddm_int,\n"
   "   k_hddm_long,\n"
   "   k_hddm_float,\n"
   "   k_hddm_double,\n"
   "   k_hddm_boolean,\n"
   "   k_hddm_string,\n"
   "   k_hddm_anyURI,\n"
   "   k_hddm_Particle_t\n"
   "};\n"
   "\n"
   "#ifdef HDF5_SUPPORT\n"
   "#define HDF5_DEFAULT_CHUNK_SIZE 100\n"
   "// gzip standard compression provided by hdf5\n"
   "const H5Z_filter_t k_hdf5_gzip_filter(H5Z_FILTER_DEFLATE);\n"
   "// szip standard compression provided by hdf5\n"
   "const H5Z_filter_t k_hdf5_szip_filter(H5Z_FILTER_SZIP);\n"
   "// bzip2 lossless compression used by PyTables\n"
   "const H5Z_filter_t k_hdf5_bzip2_plugin(307);\n"
   "// Blosc lossless compression used by PyTables\n"
   "const H5Z_filter_t k_hdf5_blosc_plugin(32001);\n"
   "// bitshuffle shuffle filter at bit level instead of byte level\n"
   "const H5Z_filter_t k_hdf5_bshuf_plugin(32008);\n"
   "// JPEG-XR compression filter used in jpeg images\n"
   "const H5Z_filter_t k_hdf5_jpeg_plugin(32007);\n"
   "// LZ4 fast lossless compression algorithm\n"
   "const H5Z_filter_t k_hdf5_lz4_plugin(32004);\n"
   "// LZF fast lossless compression used by H5Py project\n"
   "const H5Z_filter_t k_hdf5_lzf_plugin(32000);\n"
   "// modified LZMA compression filter (MAFISC)\n"
   "const H5Z_filter_t k_hdf5_lzma_plugin(32002);\n"
   "// zfp rate, accuracy, or precision bounded compression for arrays of floats\n"
   "const H5Z_filter_t k_hdf5_zfp_plugin(32013);\n"
   "#endif\n"
   "\n"
   "class HDDM;\n"
   "class istream;\n"
   "class ostream;\n"
   "\n"
   "class streamable {\n"
   " public:\n"
   "   virtual ~streamable() {}\n"
   "   virtual void streamer(istream &istr) {}\n"
   "   virtual void streamer(ostream &ostr) {}\n"
   "};\n"
   "\n"
   "class streamposition {\n"
   " public:\n"
   "   uint64_t block_start;\n"
   "   uint32_t block_offset;\n"
   "   uint32_t block_status;\n"
   "   streamposition();\n"
   "   streamposition(uint64_t start, uint32_t offset, uint32_t status);\n"
   "   bool operator==(const streamposition src) const {\n"
   "      return (block_start == src.block_start &&\n"
   "              block_offset == src.block_offset &&\n"
   "              block_status == src.block_status);\n"
   "   }\n"
   "   bool operator!=(const streamposition src) const {\n"
   "      return !(*this == src);\n"
   "   }\n"
   "   bool operator>(const streamposition src) const {\n"
   "      return (block_start > src.block_start ||\n"
   "              (block_start == src.block_start &&\n"
   "               block_offset > src.block_offset));\n"
   "   }\n"
   "   bool operator>=(const streamposition src) const {\n"
   "      return (*this > src || *this == src);\n"
   "   }\n"
   "   bool operator<(const streamposition src) const {\n"
   "      return !(*this >= src);\n"
   "   }\n"
   "   bool operator<=(const streamposition src) const {\n"
   "      return !(*this > src);\n"
   "   }\n"
   "};\n"
   "\n"
   "class threads {\n"
   " public:\n"
   "   static thread_local int ID;\n"
   "   static int getID() {\n"
   "      // protected access to the ID tls data member\n"
   "      if (ID == 0) {\n"
   "         if (ID >= max_threads) {\n"
   "            throw std::runtime_error(\"hddm_" 
                                       << classPrefix << "::threads::getID - \"\n"
   "                                     \"thread count exceeds max_threads\");\n"
   "         }\n"
   "         ID = ++next_unique_ID;\n"
   "      }\n"
   "      return ID;\n"
   "   }\n"
   "   static const int max_threads = 999;\n"
   " protected:\n"
   "   static std::atomic<int> next_unique_ID;\n"
   "};\n"
   "\n"
   "class istreambuffer : public std::streambuf {\n"
   " public:\n"
   "   istreambuffer(char* buffer, std::streamsize bufferLength) {\n"
   "      setg(buffer, buffer, buffer + bufferLength);\n"
   "   }\n"
   "\n"
   "   std::streampos tellg() {\n"
   "      return gptr() - eback();\n"
   "   }\n"
   "\n"
   "   void seekg(std::streampos pos) {\n"
   "      reset();\n"
   "      gbump(pos);\n"
   "   }\n"
   "\n"
   "   int size() {\n"
   "      return egptr() - gptr();\n"
   "   }\n"
   "\n"
   "   void reset() {\n"
   "      char *gbegin = eback();\n"
   "      char *gend = egptr();\n"
   "      setg(gbegin, gbegin, gend);\n"
   "   }\n"
   "\n"
   "   char *getbuf() {\n"
   "      return eback();\n"
   "   }\n"
   "};\n"
   "\n"
   "class ostreambuffer : public std::streambuf {\n"
   " public:\n"
   "   ostreambuffer(char* buffer, std::streamsize bufferLength) {\n"
   "      setp(buffer, buffer + bufferLength);\n"
   "   }\n"
   "\n"
   "   std::streampos tellp() {\n"
   "      return pptr() - pbase();\n"
   "   }\n"
   "\n"
   "   void seekp(std::streampos pos) {\n"
   "      reset();\n"
   "      pbump(pos);\n"
   "   }\n"
   "\n"
   "   int size() {\n"
   "      return pptr() - pbase();\n"
   "   }\n"
   "\n"
   "   void reset() {\n"
   "      char *pbegin = pbase();\n"
   "      char *pend = epptr();\n"
   "      setp(pbegin, pend);\n"
   "   }\n"
   "\n"
   "   char *getbuf() {\n"
   "      return pbase();\n"
   "   }\n"
   "};\n"
   "\n"
   "class ostream {\n"
   " public:\n"
   "   ostream(std::ostream &src);\n"
   "   ~ostream();\n"
   "   ostream &operator<<(HDDM &record);\n"
   "   int getCompression() const;\n"
   "   void setCompression(int flags);\n"
   "   int getIntegrityChecks() const;\n"
   "   void setIntegrityChecks(int flags);\n"
   "   streamposition getPosition();\n"
   "   int getBytesWritten() const;\n"
   "   int getRecordsWritten() const;\n"
   " //protected:\n"
   "   xstream::xdr::ostream *getXDRostream() {\n"
   "      return my_thread_private[threads::ID]->m_xstr;\n"
   "   }\n"
   "   ostream &operator<<(streamable &object);\n"
   " private:\n"
   "   void configure_streambufs();\n"
   "   void update_streambufs();\n"
   "   void lock_streambufs();\n"
   "   void unlock_streambufs();\n"
   "   std::ostream &m_ostr;\n"
   "   std::atomic<int> m_status_bits;\n"
   "   pthread_mutex_t m_streambuf_mutex;\n"
   "\n"
   "   typedef struct {\n"
   "      xstream::xdr::ostream *m_xstr;\n"
   "      std::ostream *m_ostr;\n"
   "      ostreambuffer *m_sbuf;\n"
   "      std::streambuf *m_xcmp;\n"
   "      char *m_event_buffer;\n"
   "      int m_event_buffer_size;\n"
   "      std::streampos m_last_start;\n"
   "      std::streamoff m_last_offset;\n"
   "      int m_status_bits;\n"
   "      int m_mutex_lock;\n"
   "      int m_bytes_written;\n"
   "      int m_records_written;\n"
   "   } thread_private_data;\n"
   "\n"
   "   thread_private_data *my_thread_private[threads::max_threads];\n"
   "   thread_private_data *lookup_private_data();\n"
   "   void init_private_data();\n"
   "};\n"
   "\n"
   "class codon {\n"
   " public:\n"
   "   codon(): m_order(0) {}\n"
   "   int m_order;\n"
   "   std::string m_tagname;\n"
   "   std::vector<codon> m_sequence;\n"
   "   std::deque<streamable*> m_target;\n"
   "};\n"
   "\n"
   "typedef std::vector<codon> chromosome;\n"
   "\n"
   "class istream {\n"
   " public:\n"
   "   istream(std::istream &src);\n"
   "   ~istream();\n"
   "   istream &operator>>(HDDM &record);\n"
   "   void skip(int count);\n"
   "   int getCompression() const;\n"
   "   int getIntegrityChecks() const;\n"
   "   streamposition getPosition();\n"
   "   void setPosition(const streamposition &pos);\n"
   "   int getBytesRead() const;\n"
   "   int getRecordsRead() const;\n"
   "   bool eof();\n"
   "   bool operator!();\n"
   "   operator void*();\n"
   " //protected:\n"
   "   void reset_sequencer();\n"
   "   void sequencer(streamable &object);\n"
   "   istream &operator>>(streamable &object);\n"
   "   xstream::xdr::istream *getXDRistream() {\n"
   "      return my_thread_private[threads::ID]->m_xstr;\n"
   "   }\n"
   "\n"
   " private:\n"
   "   std::string m_documentString;\n"
   "   chromosome synthesize(const std::string &src, int p_src,\n"
   "                         const std::string &ref, int p_ref);\n"
   "   int getTag(const std::string &src, int p_src, std::string &tag, int &level);\n"
   "   int getEndTag(const std::string &src, int p_src, const std::string &tag);\n"
   "   void collide(const std::string &itag, const std::string &rtag);\n"
   "   void configure_streambufs();\n"
   "   void update_streambufs();\n"
   "   void lock_streambufs();\n"
   "   void unlock_streambufs();\n"
   "   std::istream &m_istr;\n"
   "   std::atomic<int> m_status_bits;\n"
   "   pthread_mutex_t m_streambuf_mutex;\n"
   "   int m_leftovers[100];\n"
   "\n"
   "   typedef struct {\n"
   "      codon m_genome;\n"
   "      codon *m_codon;\n"
   "      int m_sequencing;\n"
   "      xstream::xdr::istream *m_xstr;\n"
   "      std::istream *m_istr;\n"
   "      istreambuffer *m_sbuf;\n"
   "      std::streambuf *m_xcmp;\n"
   "      int m_events_to_skip;\n"
   "      char *m_event_buffer;\n"
   "      int m_event_buffer_size;\n"
   "      int m_event_size;\n"
   "      std::streampos m_last_start;\n"
   "      std::streamoff m_last_offset;\n"
   "      std::streamoff m_next_start;\n"
   "      int m_status_bits;\n"
   "      int m_mutex_lock;\n"
   "      int m_bytes_read;\n"
   "      int m_records_read;\n"
   "      bool m_hit_eof;\n"
   "   } thread_private_data;\n"
   "\n"
   "   thread_private_data *my_thread_private[threads::max_threads];\n"
   "   thread_private_data *lookup_private_data();\n"
   "   void init_private_data();\n"
   "};\n"
   "\n"
   "template <class T> class HDDM_ElementList;\n"
   "\n"
   "class HDDM_Element: public streamable {\n"
   " public:\n"
   "   virtual ~HDDM_Element() {}\n"
   "   virtual void clear() {}\n"
   "   virtual const void *getAttribute(const std::string &name,\n"
   "                                    hddm_type *atype=0) const {\n"
   "      return 0;\n"
   "   }\n"
   "   virtual std::string toString(int indent=0) {\n"
   "      return \"bad apple\";\n"
   "   }\n"
   "   virtual std::string toXML(int indent=0) {\n"
   "      return \"<!--bad apple-->\";\n"
   "   }\n"
   "   friend class HDDM_ElementList<HDDM_Element>;\n"
   " protected:\n"
   "   HDDM_Element() : m_parent(0), m_host(0), m_owner(0) {}\n"
   "   HDDM_Element(HDDM_Element *parent, int owner=0)\n"
   "    : m_parent(parent),\n"
   "      m_host((parent != 0)? parent->m_host : 0),\n"
   "      m_owner(owner)\n"
   "   {}\n"
   "   HDDM_Element(const HDDM_Element &src)\n"
   "    : m_parent(src.m_parent),\n"
   "      m_host(src.m_host),\n"
   "      m_owner(0)\n"
   "   {}\n"
   "   HDDM_Element *m_parent;\n"
   "   HDDM *m_host;\n"
   "   int m_owner;\n"
   "};\n"
   "\n"
   "template <class T>\n"
   "class HDDM_ElementList: public streamable {\n"
   " public:\n"
   "   HDDM_ElementList() : m_host_plist(0), m_parent(0) {}\n"
   "   HDDM_ElementList(typename std::list<T*> *plist,\n"
   "                    typename std::list<T*>::iterator begin,\n"
   "                    typename std::list<T*>::iterator end,\n"
   "                    HDDM_Element *parent=0)\n"
   "    : m_host_plist(plist),\n"
   "      m_first_iter(begin),\n"
   "      m_last_iter(end),\n"
   "      m_parent(parent),\n"
   "      m_ref(0)\n"
   "   {\n"
   "      for (m_size = 0; begin != end; ++m_size, ++begin) {}\n"
   "      if (m_size) {\n"
   "         --m_last_iter;\n"
   "      }\n"
   "   }\n"
   "\n"
   "   HDDM_ElementList(const HDDM_ElementList<T> &src)\n"
   "    : m_host_plist(src.m_host_plist),\n"
   "      m_first_iter(src.m_first_iter),\n"
   "      m_last_iter(src.m_last_iter),\n"
   "      m_parent(src.m_parent),\n"
   "      m_size(src.m_size),\n"
   "      m_ref(src.m_ref)\n"
   "   {}\n"
   "\n"
   "   bool empty() const { return (m_size == 0); }\n"
   "   int size() const { return m_size; }\n"
   "   T &front() const { return *m_first_iter; }\n"
   "   T &back() const { return *m_last_iter; }\n"
   "   T &operator()() { return *m_first_iter; }\n"
   "   T &operator()(int index) {\n"
   "      if (index == 0) {\n"
   "         return *m_first_iter;\n"
   "      }\n"
   "      else if (index == -1) {\n"
   "         return *m_last_iter;\n"
   "      }\n"
   "      else if (index > 0) {\n"
   "         return *(m_first_iter + index);\n"
   "      }\n"
   "      else {\n"
   "         return *(m_last_iter + (++index));\n"
   "      }\n"
   "   }\n"
   "\n"
   "   class iterator: public std::list<T*>::iterator {\n"
   "    public:\n"
   "      iterator() {}\n"
   "      iterator(typename std::list<T*>::iterator src)\n"
   "       : std::list<T*>::iterator(src) {}\n"
   "\n"
   "      T *operator->() const { \n"
   "         return *(typename std::list<T*>::iterator)(*this);\n"
   "      }\n"
   "\n"
   "      T &operator*() const {\n"
   "         return **(typename std::list<T*>::iterator)(*this);\n"
   "      }\n"
   "\n"
   "      iterator operator+=(int offset) {\n"
   "         if (offset > 0) {\n"
   "            for (int i=0; i<offset; ++i, ++(*this)) {}\n"
   "         }\n"
   "         else if (offset < 0) {\n"
   "            for (int i=0; i>offset; --i, --(*this)) {}\n"
   "         }\n"
   "         return *this;\n"
   "      }\n"
   "\n"
   "      iterator operator-=(int offset) {\n"
   "         if (offset > 0) {\n"
   "            for (int i=0; i<offset; ++i, --(*this)) {}\n"
   "         }\n"
   "         else if (offset < 0) {\n"
   "            for (int i=0; i>offset; --i, ++(*this)) {}\n"
   "         }\n"
   "         return *this;\n"
   "      }\n"
   "\n"
   "      iterator operator+(int offset) const {\n"
   "         iterator iter(*this);\n"
   "         return iter += offset;\n"
   "      }\n"
   "\n"
   "      iterator operator-(int offset) const {\n"
   "         iterator iter(*this);\n"
   "         return iter -= offset;\n"
   "      }\n"
   "\n"
   "      int operator-(iterator iter) const {\n"
   "         if (*this == iter) {\n"
   "            return 0;\n"
   "         }\n"
   "         iterator iter2(iter);\n"
   "         for (int n=1; n < INT_MAX; ++n) {\n"
   "            if (++iter == *this) {\n"
   "               return n;\n"
   "            }\n"
   "            else if (--iter2 == *this) {\n"
   "               return -n;\n"
   "            }\n"
   "         }\n"
   "         return INT_MAX;\n"
   "      }\n"
   "      void *address() const {\n"
   "         return &*(typename std::list<T*>::iterator)(*this);\n"
   "      }\n"
   "   };\n"
   "\n"
   "   class const_iterator: public std::list<T*>::const_iterator {\n"
   "    public:\n"
   "      const_iterator() {}\n"
   "      const_iterator(const typename std::list<T*>::const_iterator src)\n"
   "       : std::list<T*>::const_iterator(src) {}\n"
   "\n"
   "      const_iterator(const typename std::list<T*>::iterator src)\n"
   "       : std::list<T*>::const_iterator(src) {}\n"
   "\n"
   "      const T *operator->() const { \n"
   "         return *(typename std::list<T*>::const_iterator)(*this);\n"
   "      }\n"
   "\n"
   "      const T &operator*() const { \n"
   "         return **(typename std::list<T*>::const_iterator)(*this);\n"
   "      }\n"
   "\n"
   "      const const_iterator operator+=(int offset) {\n"
   "         if (offset > 0) {\n"
   "            for (int i=0; i<offset; ++i, ++(*this)) {}\n"
   "         }\n"
   "         else if (offset < 0) {\n"
   "            for (int i=0; i>offset; --i, --(*this)) {}\n"
   "         }\n"
   "         return *this;\n"
   "      }\n"
   "\n"
   "      const const_iterator operator-=(int offset) {\n"
   "         if (offset > 0) {\n"
   "            for (int i=0; i<offset; ++i, --(*this)) {}\n"
   "         }\n"
   "         else if (offset > 0) {\n"
   "            for (int i=0; i>offset; --i, ++(*this)) {}\n"
   "         }\n"
   "         return *this;\n"
   "      }\n"
   "\n"
   "      const const_iterator operator+(int offset) const {\n"
   "         const_iterator iter(*this);\n"
   "         return iter += offset;\n"
   "      }\n"
   "\n"
   "      const const_iterator operator-(int offset) const {\n"
   "         const_iterator iter(*this);\n"
   "         return iter -= offset;\n"
   "      }\n"
   "\n"
   "      int operator-(const_iterator iter) const {\n"
   "         if (*this == iter) {\n"
   "            return 0;\n"
   "         }\n"
   "         const_iterator iter2(iter);\n"
   "         for (int n=1; n < m_size; ++n) {\n"
   "            if (++iter == *this) {\n"
   "               return n;\n"
   "            }\n"
   "            else if (--iter2 == *this) {\n"
   "               return -n;\n"
   "            }\n"
   "         }\n"
   "         return m_size;\n"
   "      }\n"
   "      void *address() const {\n"
   "         return &*(typename std::list<T*>::iterator)(*this);\n"
   "      }\n"
   "   };\n"
   "\n"
   "   iterator begin() const { return m_first_iter; }\n"
   "   iterator end() const { return (m_size)? m_last_iter + 1 : m_last_iter; }\n"
   "   void clear() { del(); }\n"
   "\n"
   "   HDDM_ElementList add(int count=1, int start=-1) {\n"
   "      if (m_parent == 0) {\n"
   "         throw std::runtime_error(\"HDDM_ElementList error - \"\n"
   "                                  \"attempt to add to immutable list\");\n"
   "      }\n"
   "      iterator it = insert(start, count);\n"
   "      typename std::list<T*>::iterator iter(it);\n"
   "      for (int n=0; n<count; ++n, ++iter) {\n"
   "         *iter = new T(m_parent, 1);\n"
   "      }\n"
   "      return HDDM_ElementList(m_host_plist, it, it+count, m_parent);\n"
   "   }\n"
   "\n"
   "   void del(int count=-1, int start=0) {\n"
   "      if (m_size == 0 || count == 0) {\n"
   "         return;\n"
   "      }\n"
   "      if (m_parent == 0) {\n"
   "         throw std::runtime_error(\"HDDM_ElementList error - \"\n"
   "                                  \"attempt to delete from immutable list\");\n"
   "      }\n"
   "      iterator iter_begin(begin());\n"
   "      iterator iter_end(end());\n"
   "      if (start < 0) {\n"
   "         iter_begin = iter_end + start;\n"
   "         if (count >= 0) {\n"
   "            iter_end = iter_begin + count;\n"
   "         }\n"
   "      }\n"
   "      else {\n"
   "         iter_begin += start;\n"
   "         if (count >= 0) {\n"
   "            iter_end = iter_begin + count;\n"
   "         }\n"
   "      }\n"
   "      typename std::list<T*>::iterator iter;\n"
   "      for (iter = iter_begin; iter != iter_end; ++iter) {\n"
   "         if ((*iter)->m_owner)\n"
   "            delete *iter;\n"
   "         else\n"
   "            (*iter)->clear();\n"
   "      }\n"
   "      erase(start, count);\n"
   "   }\n"
   "\n"
   "   HDDM_ElementList slice(int first=0, int last=-1) {\n"
   "      int n1 = (first < 0)? first + m_size : first;\n"
   "      int n2 = (last < 0)? last + m_size + 1 : last + 1;\n"
   "      int count = n2 - n1;\n"
   "      iterator iter_begin;\n"
   "      if (first >= 0)\n"
   "         iter_begin = begin() + first;\n"
   "      else\n"
   "         iter_begin = end() + first;\n"
   "      iterator iter_end(iter_begin + count);\n"
   "      return HDDM_ElementList(m_host_plist, iter_begin, iter_end);\n"
   "   }\n"
   "   void debug_print() {\n"
   "      std::cout << \"HDDM_ElementList<T> contents printout:\"\n"
   "                << std::endl\n"
   "                << \"    this         = \" << &*this << std::endl\n"
   "                << \"    m_parent     = \" << m_parent << std::endl\n"
   "                << \"    m_host_plist = \" << m_host_plist << std::endl\n"
   "                << \"    m_size       = \" << m_size << std::endl\n"
   "                << \"    m_ref        = \" << m_ref << std::endl\n"
   "                << \"    m_first_iter = \" << m_first_iter.address()\n"
   "                << std::endl\n"
   "                << \"    m_last_iter  = \" << m_last_iter.address()\n"
   "                << std::endl;\n"
   "   }\n"
   "\n"
   "   void streamer(istream &istr) {\n"
   "      clear();\n"
   "      int size;\n"
   "      *istr.getXDRistream() >> size;\n"
   "      if (size) {\n"
   "         iterator iter = add(size).begin();\n"
   "         for (int n=0; n < size; ++n, ++iter) {\n"
   "            istr.sequencer(*iter);\n"
   "         }\n"
   "      }\n"
   "      istr.reset_sequencer();\n"
   "   }\n"
   "\n"
   "   void streamer(ostream &ostr) {\n"
   "      if (m_size) {\n"
   "         *ostr.getXDRostream() << m_size;\n"
   "         for (iterator iter = begin(); iter != end(); ++iter) {\n"
   "            iter->streamer(ostr);\n"
   "         }\n"
   "      }\n"
   "   }\n"
   "   std::string toString(int indent=0) {\n"
   "      std::string result;\n"
   "      if (m_size) {\n"
   "         for (iterator iter = begin(); iter != end(); ++iter) {\n"
   "            result += iter->toString(indent);\n"
   "         }\n"
   "      }\n"
   "      return result;\n"
   "   }\n"
   "   std::string toXML(int indent=0) {\n"
   "      std::string result;\n"
   "      if (m_size) {\n"
   "         for (iterator iter = begin(); iter != end(); ++iter) {\n"
   "            result += iter->toXML(indent);\n"
   "         }\n"
   "      }\n"
   "      return result;\n"
   "   }\n"
   "\n"
   " private:\n"
   "   iterator insert(int start, int count) {\n"
   "      if (m_size == 0) {\n"
   "         if (count > 0) {\n"
   "            if (m_first_iter == m_host_plist->begin()) {\n"
   "               m_host_plist->insert(m_first_iter,count,(T*)0);\n"
   "               m_first_iter = m_host_plist->begin();\n"
   "            }\n"
   "            else {\n"
   "               m_host_plist->insert(m_first_iter--,count,(T*)0);\n"
   "               ++m_first_iter;\n"
   "            }\n"
   "            --m_last_iter;\n"
   "            m_size = count;\n"
   "         }\n"
   "         return m_first_iter;\n"
   "      }\n"
   "      else if (start == 0) {\n"
   "         if (count > 0) {\n"
   "            if (m_first_iter == m_host_plist->begin()) {\n"
   "               m_host_plist->insert(m_first_iter,count,(T*)0);\n"
   "               m_first_iter = m_host_plist->begin();\n"
   "            }\n"
   "            else {\n"
   "               m_host_plist->insert(m_first_iter--,count,(T*)0);\n"
   "               ++m_first_iter;\n"
   "            }\n"
   "            m_size += count;\n"
   "         }\n"
   "         return m_first_iter;\n"
   "      }\n"
   "      else if (start == -1) {\n"
   "         if (count > 0) {\n"
   "            iterator pos(m_last_iter);\n"
   "            m_host_plist->insert(++m_last_iter,count,(T*)0);\n"
   "            --m_last_iter;\n"
   "            m_size += count;\n"
   "            return ++pos;\n"
   "         }\n"
   "         return m_last_iter;\n"
   "      }\n"
   "      else if (start > 0) {\n"
   "         if (count > 0) {\n"
   "            iterator pos(m_first_iter);\n"
   "            iterator pos2(pos += start-1);\n"
   "            m_host_plist->insert(++pos,count,(T*)0);\n"
   "            if (m_last_iter == pos2) {\n"
   "               m_last_iter = --pos;\n"
   "            }\n"
   "            m_size += count;\n"
   "            return ++pos2;\n"
   "         }\n"
   "         return m_first_iter + start;\n"
   "      }\n"
   "      else {\n"
   "         if (count > 0) {\n"
   "            iterator pos(m_last_iter);\n"
   "            iterator pos2(pos += start+1);\n"
   "            m_host_plist->insert(++pos,count,(T*)0);\n"
   "            m_size += count;\n"
   "            return ++pos2;\n"
   "         }\n"
   "         return m_last_iter + (start+1);\n"
   "      }\n"
   "   }\n"
   "\n"
   "   iterator erase(int start, int count) {\n"
   "      start = (start < 0)? start + m_size :\n"
   "              (start < m_size)? start : m_size;\n"
   "      count = (count == -1)? m_size - start : count;\n"
   "      assert(start >= 0 && count > 0 && start + count <= m_size);\n"
   "      if (count == m_size) {\n"
   "         m_first_iter = m_host_plist->erase(m_first_iter,++m_last_iter);\n"
   "         m_last_iter = m_first_iter;\n"
   "         m_size = 0;\n"
   "         return m_first_iter;\n"
   "      }\n"
   "      else if (start > 0 && count + start == m_size) {\n"
   "         iterator pos(m_first_iter + start);\n"
   "         m_last_iter = m_host_plist->erase(pos,pos+count);\n"
   "         iterator pos2(m_last_iter);\n"
   "         if (m_last_iter != m_first_iter) {\n"
   "            --m_last_iter;\n"
   "         }\n"
   "         m_size -= count;\n"
   "         return pos2;\n"
   "      }\n"
   "      else if (start == 0) {\n"
   "         iterator pos(m_first_iter);\n"
   "         m_first_iter = m_host_plist->erase(pos,pos+count);\n"
   "         m_size -= count;\n"
   "         return m_first_iter;\n"
   "      }\n"
   "      else {\n"
   "         iterator pos(m_first_iter + start);\n"
   "         iterator pos2 = m_host_plist->erase(pos,pos+count);\n"
   "         m_size -= count;\n"
   "         return pos2;\n"
   "      }\n"
   "   }\n"
   "\n"
   " public:\n"
   "   void inflate(HDDM *host, std::list<T*> *host_plist, HDDM_Element *parent) {\n"
   "      m_parent = parent;\n"
   "      m_host_plist = host_plist;\n"
   "      m_first_iter = m_host_plist->begin();\n"
   "      m_first_iter += m_ref;\n"
   "      m_last_iter = m_first_iter;\n"
   "      m_last_iter += m_size;\n"
   "      for (iterator iter = m_first_iter; iter != m_last_iter; ++iter) {\n"
   "         iter->m_parent = parent;\n"
   "         iter->m_host = host;\n"
   "      }\n"
   "      if (m_size) {\n"
   "         --m_last_iter;\n"
   "      }\n"
   "   }\n"
   "   void deflate() {\n"
   "      iterator iter = m_host_plist->begin();\n"
   "      for (m_ref=0; iter != m_first_iter; ++iter, ++m_ref) {}\n"
   "   }\n"
   "\n"
   " protected:\n"
   "   std::list<T*> *m_host_plist;\n"
   "   iterator m_first_iter;\n"
   "   iterator m_last_iter;\n"
   "   HDDM_Element *m_parent;\n"
   " public:\n"
   "   int m_size;\n"
   "   int m_ref;\n"
   "};\n"
   "\n"
   "template <class T>\n"
   "class HDDM_ElementLink: public HDDM_ElementList<T> {\n"
   " public:\n"
   "   HDDM_ElementLink() {}\n"
   "   HDDM_ElementLink(typename std::list<T*> *plist,\n"
   "                    typename std::list<T*>::iterator begin,\n"
   "                    typename std::list<T*>::iterator end,\n"
   "                    HDDM_Element *parent=0)\n"
   "    : HDDM_ElementList<T>(plist,begin,end,parent)\n"
   "   {}\n"
   "   HDDM_ElementLink(const HDDM_ElementList<T> &src)\n"
   "    : HDDM_ElementList<T>(src)\n"
   "   {}\n"
   "\n"
   "   void streamer(istream &istr) {\n"
   "      HDDM_ElementList<T>::clear();\n"
   "      HDDM_ElementList<T>::add().begin()->streamer(istr);\n"
   "   }\n"
   "\n"
   "   void streamer(ostream &ostr) {\n"
   "      if (HDDM_ElementList<T>::m_size) {\n"
   "         HDDM_ElementList<T>::begin()->streamer(ostr);\n"
   "      }\n"
   "   }\n"
   "};\n"
   "\n"
   "#ifdef HDF5_SUPPORT\n"
   "typedef struct {\n"
   "   size_t len;\n"
   "   void *p;\n"
   "} hdf5_hvl_t;\n"
   "#endif\n"
   "\n"
   ;

   builder.cFile <<
   "/*\n"
   " * hddm_" << classPrefix << "++.cpp - DO NOT EDIT THIS FILE\n"
   " *\n"
   " * This file was generated automatically by hddm-cpp from the file\n"
   << " * " << xmlFile << std::endl <<
   "\n"
   " * This c++ source implements the methods for the classes \n"
   " * described in the data model (from " << xmlFile << "). \n"
   " *\n"
   " * The hddm data model tool set was written by\n"
   " * Richard Jones, University of Connecticut.\n"
   " *\n"
   " * For more information see the documentation at\n"
   " * http://github.com/rjones30/HDDM\n"
   " */\n"
   "\n"
   "#include <sstream>\n"
   "#include \"hddm_" << classPrefix << ".hpp\"\n"
   "\n"
   "#ifndef _FILE_OFFSET_BITS\n"
   "# define _FILE_OFFSET_BITS 64\n"
   "#endif\n"
   "\n"
   "using namespace hddm_" << classPrefix << ";\n"
   "\n"
   "std::atomic<int> threads::next_unique_ID(0);\n"
   "thread_local int threads::ID(0);\n"
   "\n"
   "static int tags_match(const std::string &a, const std::string &b)\n"
   "{\n"
   "   if (a == b) {\n"
   "      return true;\n"
   "   }\n"
   "   else if (a.find(\"<HDDM \") == 0 && b.find(\"<HDDM \") == 0) {\n"
   "      return true;\n"
   "   }\n"
   "   else {\n"
   "      int len = a.length();\n"
   "      int ia=0;\n"
   "      int ib=0;\n"
   "      for (; a[ia] == b[ib]; ++ia, ++ib, --len) {}\n"
   "      for (; a[ia] == ' '; ++ia, --len) {}\n"
   "      for (; a[ia] == '/'; ++ia, --len) {}\n"
   "      for (; b[ib] == ' '; ++ib) {}\n"
   "      for (; b[ib] == '/'; ++ib) {}\n"
   "      return (a.substr(ia) == b.substr(ib));\n"
   "   }\n"
   "}\n"
   "\n"
   ;

   builder.constructGroup(rootEl);
   builder.constructIOstreams(rootEl);
   builder.constructMethods(rootEl);
   builder.constructStreamers(rootEl);

   builder.hFile <<
   "inline std::string HDDM::DocumentString() {\n"
   "   return std::string(\n"
   ;
   builder.constructDocument(rootEl);
   builder.hFile <<
   "   );\n"
   "}\n"
   "\n"
   "}\n"
   "#endif /* SAW_" << classPrefix << "_HDDM */\n"
   ;

   builder.cFile <<
   "\n"
   "streamposition::streamposition()\n"
   " : block_start(), block_offset(), block_status() {}\n"
   "\n"
   "streamposition::streamposition(uint64_t start, uint32_t offset, uint32_t status)\n"
   " : block_start(start), block_offset(offset), block_status(status) {}\n"
   "\n"
   "istream::istream(std::istream &src)\n"
   " : m_istr(src),\n"
   "   m_status_bits(0)\n"
   "{\n"
   "   char hdr[1000];\n"
   "   src.getline(hdr,7);\n"
   "   m_documentString = hdr;\n"
   "   while (m_documentString != \"<HDDM \") {\n"
   "      if (m_documentString == \"<?xml \") {\n"
   "         src.clear();\n"
   "         src.getline(hdr,1000);\n"
   "         src.getline(hdr,7);\n"
   "         m_documentString = hdr;\n"
   "         continue;\n"
   "      }\n"
   "      throw std::runtime_error(\"hddm_" + classPrefix +
   "::istream::istream error - invalid hddm header\");\n"
   "   }\n"
   "   src.clear();\n"
   "   std::string line;\n"
   "   while (std::getline(src,line).good()) {\n"
   "      m_documentString += line + \"\\n\";\n"
   "      if (line == \"</HDDM>\") {\n"
   "         break;\n"
   "      }\n"
   "   }\n"
   "   if (src.bad()) {\n"
   "      throw std::runtime_error(\"hddm_" + classPrefix +
   "::istream::istream error - hddm header invalid\");\n"
   "   }\n"
   "   pthread_mutex_init(&m_streambuf_mutex,0);\n"
   "   for (int i=0; i<threads::max_threads; ++i) {\n"
   "      my_thread_private[i] = 0;\n"
   "   }\n"
   "   m_leftovers[0] = 0;\n"
   "   init_private_data();\n"
   "}\n"
   "\n"
   "istream::~istream() {\n"
   "   pthread_mutex_destroy(&m_streambuf_mutex);\n"
   "   for (int i=0; i<threads::max_threads; ++i) {\n"
   "      thread_private_data *my_private = my_thread_private[i];\n"
   "      if (my_private != 0) {\n"
   "         if (MY(istr))\n"
   "            delete MY(istr);\n"
   "         if (MY(xcmp))\n"
   "            delete MY(xcmp);\n"
   "         if (MY(xstr))\n"
   "            delete MY(xstr);\n"
   "         if (MY(sbuf))\n"
   "            delete MY(sbuf);\n"
   "         delete [] MY(event_buffer);\n"
   "         delete my_private;\n"
   "      }\n"
   "   }\n"
   "}\n"
   "\n"
   "void istream::init_private_data() {\n"
   "   int threadID = threads::getID();\n"
   "   if (my_thread_private[threadID] == 0) {\n"
   "      my_thread_private[threadID] = new thread_private_data;\n"
   "   }\n"
   "   MY_SETUP\n"
   "   MY(genome).m_tagname = \"HDDM\";\n"
   "   MY(genome).m_sequence = synthesize(m_documentString,0,HDDM::DocumentString(),0);\n"
   "   MY(event_buffer) = new char[MY(event_buffer_size) = 100000];\n"
   "   MY(sbuf) = new istreambuffer(MY(event_buffer),MY(event_buffer_size));\n"
   "   MY(xstr) = new xstream::xdr::istream(MY(sbuf));\n"
   "   MY(istr) = new std::istream(m_istr.rdbuf());\n"
   "   MY(xcmp) = 0;\n"
   "   MY(event_size) = 0;\n"
   "   MY(last_start) = 0;\n"
   "   MY(last_offset) = 0;\n"
   "   MY(next_start) = 0;\n"
   "   MY(events_to_skip) = 0;\n"
   "   MY(status_bits) = 0;\n"
   "   MY(mutex_lock) = 0;\n"
   "   MY(bytes_read) = 0;\n"
   "   MY(records_read) = 0;\n"
   "   MY(sequencing) = 0;\n"
   "   MY(hit_eof) = 0;\n"
   "}\n"
   "\n"
   "streamposition istream::getPosition() {\n"
   "   MY_SETUP\n"
   "   streamposition pos;\n"
   "   pos.block_start = MY(last_start);\n"
   "   pos.block_offset = MY(last_offset);\n"
   "   pos.block_status = MY(status_bits);\n"
   "   return pos;\n"
   "}\n"
   "\n"
   "void istream::setPosition(const streamposition &pos) {\n"
   "   MY_SETUP\n"
   "   m_status_bits = pos.block_status;\n"
   "   lock_streambufs();\n"
   "   update_streambufs();\n"
   "   unlock_streambufs();\n"
   "   if (MY(status_bits) & (k_bz2_compression | k_z_compression)) {\n"
   "      if (((int)m_status_bits & k_bits_compression) != 0 &&\n"
   "          ((int)m_status_bits & k_can_reposition) == 0)\n"
   "      {\n"
   "         throw std::runtime_error(\"hddm_"
                        << classPrefix << "::istream::setPosition error - \"\n"
   "                                  \"old-format hddm input file does not support repositioning.\");\n"
   "      }\n"
   "      else if (MY(xcmp) == 0) {\n"
   "         throw std::runtime_error(\"hddm_"
                        << classPrefix << "::istream::setPosition error - \"\n"
   "                                  \"compressed stream encountered but no decompressor configured.\");\n"
   "      }\n"
   "      if (MY(status_bits) & k_z_compression) {\n"
   "         ((xstream::z::istreambuf*)MY(xcmp))->\n"
   "             set_new_position(pos.block_start, pos.block_offset);\n"
   "      }\n"
   "      else if (MY(status_bits) & k_bz2_compression) {\n"
   "         ((xstream::bz::istreambuf*)MY(xcmp))->\n"
   "             set_new_position(pos.block_start, pos.block_offset);\n"
   "      }\n"
   "   }\n"
   "   else {\n"
   "      MY(next_start) = pos.block_start;\n"
   "   }\n"
   "}\n"
   "\n"
   "void istream::update_streambufs() {\n"
   "   MY_SETUP\n"
   "   if ((int)m_status_bits != MY(status_bits)) {\n"
   "      configure_streambufs();\n"
   "   }\n"
   "}\n"
   "\n" 
   "void istream::configure_streambufs() {\n"
   "   MY_SETUP\n"
   "   int oldcmp = MY(status_bits) & k_bits_compression;\n"
   "   int newcmp = (int)m_status_bits & k_bits_compression;\n"
   "   if (oldcmp != newcmp) {\n"
   "      if (oldcmp != k_no_compression) {\n"
   "         MY(istr)->rdbuf(m_istr.rdbuf());\n"
   "         delete MY(xcmp);\n"
   "         MY(xcmp) = 0;\n"
   "      }\n"
   "      if (newcmp == k_z_compression) {\n"
   "         //std::cerr << \"input switched on z compression\" << std::endl;\n"
   "         MY(xcmp) = new xstream::z::istreambuf(m_istr.rdbuf(), m_leftovers,\n"
   "                                                        sizeof(m_leftovers));\n"
   "         MY(istr)->rdbuf(MY(xcmp));\n"
   "      }\n"
   "      else if (newcmp == k_bz2_compression) {\n"
   "         //std::cerr << \"input switched on bz2 compression\" << std::endl;\n"
   "         MY(xcmp) = new xstream::bz::istreambuf(m_istr.rdbuf(), m_leftovers,\n"
   "                                                         sizeof(m_leftovers));\n"
   "         MY(istr)->rdbuf(MY(xcmp));\n"
   "      }\n"
   "      else if (newcmp != k_no_compression) {\n"
   "         throw std::runtime_error(\"hddm_"
                 << classPrefix << "::istream::configure_streambufs error - \"\n"
   "                                  \"unrecognized compression flag requested.\");\n"
   "      }\n"
   "   }\n"
   "   MY(status_bits) = m_status_bits;\n"
   "}\n"
   "\n"
   "void istream::lock_streambufs() {\n"
   "   MY_SETUP\n"
   "   if (MY(mutex_lock) != 0) {\n"
   "      unlock_streambufs();\n"
   "      throw std::runtime_error(\"hddm_"
                   << classPrefix << "::istream::lock_streambufs error - \"\n"
   "                               \"mutex lock requested when lock already held.\");\n"
   "   }\n"
   "   if ((MY(status_bits) & k_bits_compression) == k_no_compression) {\n"
   "      pthread_mutex_lock(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 1;\n"
   "   }\n"
   "   else if ((MY(status_bits) & k_bits_compression) == k_z_compression) {\n"
   "      ((xstream::z::istreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 2;\n"
   "   }\n"
   "   else if ((MY(status_bits) & k_bits_compression) == k_bz2_compression) {\n"
   "      ((xstream::bz::istreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 3;\n"
   "   }\n"
   "   else {\n"
   "      MY(mutex_lock) = -1;\n"
   "   }\n"
   "}\n"
   "\n"
   "void istream::unlock_streambufs() {\n"
   "   MY_SETUP\n"
   "   if (MY(mutex_lock) == 0) {\n"
   "      throw std::runtime_error(\"hddm_"
                << classPrefix << "::istream::unlock_streambufs error - \"\n"
   "                               \"mutex unlock requested when lock not held.\");\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 1) {\n"
   "      pthread_mutex_unlock(&m_streambuf_mutex);\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 2) {\n"
   "      ((xstream::z::istreambuf*)MY(xcmp))->set_streambuf_mutex(0);\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 3) {\n"
   "      ((xstream::bz::istreambuf*)MY(xcmp))->set_streambuf_mutex(0);\n"
   "   }\n"
   "   MY(mutex_lock) = 0;\n"
   "}\n"
   "\n"
   "istream &istream::operator>>(HDDM &record) {\n"
   "   MY_SETUP\n"
   "   while (1 == 1) {\n"
   "      lock_streambufs();\n"
   "      MY(event_size) = 0;\n"
   "      while (MY(event_size) == 0) {\n"
   "         update_streambufs();\n"
   "         if (MY(status_bits) & (k_bz2_compression | k_z_compression)) {\n"
   "            if (MY(status_bits) & k_can_reposition) {\n"
   "               MY(istr)->clear();\n"
   "               MY(istr)->read(MY(event_buffer),4);\n"
   "               MY(bytes_read) += MY(istr)->gcount();\n"
   "               if (!MY(istr)->good()) {\n"
   "                  unlock_streambufs();\n"
   "                  MY(hit_eof) = 1;\n"
   "                  return *this;\n"
   "               }\n"
   "               if (MY(status_bits) & k_bz2_compression) {\n"
   "                  MY(last_start)  = dynamic_cast<xstream::bz::istreambuf*>\n"
   "                                    (MY(xcmp))->get_block_start();\n"
   "                  MY(last_offset) = dynamic_cast<xstream::bz::istreambuf*>\n"
   "                                    (MY(xcmp))->get_block_offset();\n"
   "               }\n"
   "               else {\n"
   "                  MY(last_start)  = dynamic_cast<xstream::z::istreambuf*>\n"
   "                                    (MY(xcmp))->get_block_start();\n"
   "                  MY(last_offset) = dynamic_cast<xstream::z::istreambuf*>\n"
   "                                    (MY(xcmp))->get_block_offset();\n"
   "               }\n"
   "               MY(last_offset) -= 4;\n"
   "            }\n"
   "            else {\n"
   "               MY(last_start) = 0;\n"
   "               MY(last_offset) = 0;\n"
   "            }\n"
   "         }\n"
   "         else {\n"
   "            if (MY(next_start) > 0) {\n"
   "               m_istr.seekg(MY(next_start), std::ios_base::beg);\n"
   "               MY(istr)->clear();\n"
   "               MY(last_start) = MY(next_start);\n"
   "               MY(last_offset) = 0;\n"
   "               MY(next_start) = 0;\n"
   "            }\n"
   "            else {\n"
   "               MY(last_start) = m_istr.tellg();\n"
   "               MY(last_offset) = 0;\n"
   "            }\n"
   "            MY(istr)->read(MY(event_buffer),4);\n"
   "            MY(bytes_read) += MY(istr)->gcount();\n"
   "            if (!MY(istr)->good()) {\n"
   "               unlock_streambufs();\n"
   "               MY(hit_eof) = 1;\n"
   "               return *this;\n"
   "            }\n"
   "         }\n"
   "         MY(hit_eof) = 0;\n"
   "         MY(sbuf)->reset();\n"
   "         *MY(xstr) >> MY(event_size);\n"
   "         if (MY(event_size) == 1) {\n"
   "            MY(istr)->read(MY(event_buffer)+4,4);\n"
   "            MY(bytes_read) += MY(istr)->gcount();\n"
   "            if (!MY(istr)->good()) {\n"
   "               unlock_streambufs();\n"
   "               throw std::runtime_error(\"hddm_"
                      << classPrefix << "::istream::operator>> error -\"\n"
   "                                        \" read error on token input!\");\n"
   "            }\n"
   "            int size;\n"
   "            *MY(xstr) >> size;\n"
   "            MY(istr)->read(MY(event_buffer)+8,size);\n"
   "            MY(bytes_read) += MY(istr)->gcount();\n"
   "            if (!MY(istr)->good()) {\n"
   "               unlock_streambufs();\n"
   "               throw std::runtime_error(\"hddm_"
                           << classPrefix << "::istream::operator>> error -\"\n"
   "                                        \" read error on token input!\");\n"
   "            }\n"
   "            int format, flags;\n"
   "            *MY(xstr) >> format >> flags;\n"
   "            if (format != 0) {\n"
   "               unlock_streambufs();\n"
   "               throw std::runtime_error(\"hddm_"
                          << classPrefix << "::istream::operator>> error - \"\n"
   "                                        \"unsupported compression format!\");\n"
   "            }\n"
   "            m_status_bits.store(flags);\n"
   "            MY(event_size) = 0;\n"
   "         }\n"
   "      }\n"
   "      if (MY(event_size)+8 > MY(event_buffer_size)) {\n"
   "         delete MY(xstr);\n"
   "         delete MY(sbuf);\n"
   "         char *newbuf = new char[MY(event_buffer_size) = MY(event_size)+1000];\n"
   "         MY(sbuf) = new istreambuffer(newbuf, MY(event_buffer_size));\n"
   "         MY(xstr) = new xstream::xdr::istream(MY(sbuf));\n"
   "         memcpy(newbuf,MY(event_buffer),4);\n"
   "         delete [] MY(event_buffer);\n"
   "         MY(event_buffer) = newbuf;\n"
   "      }\n"
   "      MY(istr)->read(MY(event_buffer)+4,MY(event_size));\n"
   "      MY(bytes_read) += MY(istr)->gcount();\n"
   "      MY(records_read)++;\n"
   "      if (!MY(istr)->good()) {\n"
   "         unlock_streambufs();\n"
   "         throw std::runtime_error(\"hddm_"
                    << classPrefix << "::istream::operator>> error -\"\n"
   "                                  \" read error in mid-record!\");\n"
   "      }\n"
   "      if ((MY(status_bits) & k_crc32_integrity) != 0) {\n"
   "         unsigned int recorded_crc;\n"
   "         char crcbuf[10];\n"
   "         istreambuffer sbuf(crcbuf,10);\n"
   "         xstream::xdr::istream xstr(&sbuf);\n"
   "         MY(istr)->read(crcbuf,4);\n"
   "         MY(bytes_read) += MY(istr)->gcount();\n"
   "         xstr >> recorded_crc;\n"
   "         xstream::digest::crc32 crc;\n"
   "         std::ostream out(&crc);\n"
   "         out.write(MY(event_buffer),MY(event_size)+4);\n"
   "         out.flush();\n"
   "         if (crc.digest() != recorded_crc) {\n"
   "            char errmsg[] = \n"
   "                 \"WARNING: crc data integrity check failed\"\n"
   "                 \" on hddm_" << classPrefix << " input stream!\";\n"
   "            if ((MY(status_bits) & 0x02) == 0) {\n"
   "               std::cerr << errmsg << std::endl;\n"
   "               MY(status_bits) |= 0x02;\n"
   "            }\n"
   "            //unlock_streambufs();\n"
   "            //throw std::runtime_error(\"hddm_"
                        << classPrefix << "::istream::operator>> error -\"\n"
   "            //                 \" crc check error on input stream!\");\n"
   "         }\n"
   "      }\n"
   "      unlock_streambufs();\n"
   "      if (MY(events_to_skip) > 0) {\n"
   "         --MY(events_to_skip);\n"
   "      }\n"
   "      else {\n"
   "         break;\n"
   "      }\n"
   "   }\n"
   "   MY(sbuf)->reset();\n"
   "   MY(sequencing) = 0;\n"
   "   MY(codon) = &MY(genome);\n"
   "   record.clear();\n"
   "   *this >> (streamable&)record;\n"
   "   return *this;\n"
   "}\n"
   "\n"
   "ostream::ostream(std::ostream &src)\n"
   " : m_ostr(src),\n"
   "   m_status_bits(k_default_status)\n"
   "{\n"
   "   m_ostr << HDDM::DocumentString();\n"
   "   if (!m_ostr.good()) {\n"
   "      throw std::runtime_error(\"hddm_" + classPrefix +
   "::ostream::ostream(ostream) \"\n"
   "                               \"error - write error on header output!\");\n"
   "   }\n"
   "   pthread_mutex_init(&m_streambuf_mutex,0);\n"
   "   for (int i=0; i<threads::max_threads; ++i) {\n"
   "      my_thread_private[i] = 0;\n"
   "   }\n"
   "   init_private_data();\n"
   "}\n"
   "\n"
   "ostream::~ostream() {\n"
   "   pthread_mutex_destroy(&m_streambuf_mutex);\n"
   "   for (int i=0; i<threads::max_threads; ++i) {\n"
   "      thread_private_data *my_private = my_thread_private[i];\n"
   "      if (my_private != 0) {\n"
   "         if (MY(xstr)) {\n"
   "            delete MY(xstr);\n"
   "         }\n"
   "         if (MY(sbuf)) {\n"
   "            delete MY(sbuf);\n"
   "         }\n"
   "         if (MY(xcmp)) {\n"
   "            MY(xcmp)->pubsync();\n"
   "            MY(ostr)->rdbuf(m_ostr.rdbuf());\n"
   "            delete MY(xcmp);\n"
   "         }\n"
   "         if (MY(ostr)) {\n"
   "            MY(ostr)->flush();\n"
   "            delete MY(ostr);\n"
   "         }\n"
   "         delete [] MY(event_buffer);\n"
   "         delete my_private;\n"
   "      }\n"
   "   }\n"
   "}\n"
   "\n"
   "void ostream::init_private_data() {\n"
   "   int threadID = threads::getID();\n"
   "   if (my_thread_private[threadID] == 0) {\n"
   "      my_thread_private[threadID] = new thread_private_data;\n"
   "   }\n"
   "   MY_SETUP\n"
   "   MY(event_buffer) = new char[MY(event_buffer_size) = 100000];\n"
   "   MY(sbuf) = new ostreambuffer(MY(event_buffer),MY(event_buffer_size));\n"
   "   MY(xstr) = new xstream::xdr::ostream(MY(sbuf));\n"
   "   MY(ostr) = new std::ostream(m_ostr.rdbuf());\n"
   "   MY(xcmp) = 0;\n"
   "   MY(last_start) = 0;\n"
   "   MY(last_offset) = 0;\n"
   "   MY(records_written) = 0;\n"
   "   MY(bytes_written) = 0;\n"
   "   MY(status_bits) = 0;\n"
   "   MY(mutex_lock) = 0;\n"
   "}\n"
   "\n"
   "void ostream::setCompression(int flags) {\n"
   "   MY_SETUP\n"
   "   int oldcmp = (int)m_status_bits & k_bits_compression;\n"
   "   int newcmp = flags & k_bits_compression;\n"
   "   if (oldcmp != newcmp) {\n"
   "      m_status_bits.fetch_and(~k_bits_compression | flags);\n"
   "      m_status_bits.fetch_or(k_bits_compression & flags);\n"
   "      if (newcmp != 0)\n"
   "         m_status_bits.fetch_or(k_can_reposition);\n"
   "      MY(sbuf)->reset();\n"
   "      *MY(xstr) << 1 << 8 << 0 << (int)m_status_bits;\n"
   "      lock_streambufs();\n"
   "      MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());\n"
   "      if (!MY(ostr)->good()) {\n"
   "         unlock_streambufs();\n"
   "         throw std::runtime_error(\"hddm_"
                        << classPrefix << "::ostream::setCompression\"\n"
   "                                  \" error - write error on token output!\");\n"
   "      }\n"
   "      MY(ostr)->flush();\n"
   "      update_streambufs();\n"
   "      unlock_streambufs();\n"
   "   }\n"
   "}\n"
   "\n"
   "void ostream::setIntegrityChecks(int flags) {\n"
   "   MY_SETUP\n"
   "   int oldint = (int)m_status_bits & k_bits_integrity;\n"
   "   int newint = flags & k_bits_integrity;\n"
   "   if (oldint != newint) {\n"
   "      m_status_bits.fetch_and(~k_bits_integrity | flags);\n"
   "      m_status_bits.fetch_or(k_bits_integrity & flags);\n"
   "      MY(sbuf)->reset();\n"
   "      *MY(xstr) << 1 << 8 << 0 << (int)m_status_bits;\n"
   "      lock_streambufs();\n"
   "      MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());\n"
   "      if (!MY(ostr)->good()) {\n"
   "         unlock_streambufs();\n"
   "         throw std::runtime_error(\"hddm_"
                       << classPrefix << "::ostream::setIntegrityChecks\"\n"
   "                                 \" error - write error on token output!\");\n"
   "      }\n"
   "      MY(ostr)->flush();\n"
   "      update_streambufs();\n"
   "      unlock_streambufs();\n"
   "   }\n"
   "}\n"
   "\n" 
   "streamposition ostream::getPosition() {\n"
   "   MY_SETUP\n"
   "   streamposition pos;\n"
   "   pos.block_start = MY(last_start);\n"
   "   pos.block_start = MY(last_offset);\n"
   "   pos.block_status = MY(status_bits);\n"
   "   return pos;\n"
   "}\n"
   "\n"
   "void ostream::update_streambufs() {\n"
   "   MY_SETUP\n"
   "   if ((int)m_status_bits != MY(status_bits)) {\n"
   "      configure_streambufs();\n"
   "   }\n"
   "}\n"
   "\n"
   "void ostream::configure_streambufs() {\n"
   "   MY_SETUP\n"
   "   int oldcmp = MY(status_bits) & k_bits_compression;\n"
   "   int newcmp = (int)m_status_bits & k_bits_compression;\n"
   "   if (oldcmp != newcmp) {\n"
   "      if (oldcmp != k_no_compression) {\n"
   "         MY(ostr)->rdbuf(m_ostr.rdbuf());\n"
   "         delete MY(xcmp);\n"
   "         MY(xcmp) = 0;\n"
   "      }\n"
   "      if (newcmp == k_z_compression) {\n"
   "         //std::cerr << \"output switched on z compression\" << std::endl;\n"
   "         MY(xcmp) = new xstream::z::ostreambuf(m_ostr.rdbuf());\n"
   "         MY(ostr)->rdbuf(MY(xcmp));\n"
   "      }\n"
   "      else if (newcmp == k_bz2_compression) {\n"
   "         //std::cerr << \"output switched on bz2 compression\" << std::endl;\n"
   "         MY(xcmp )= new xstream::bz::ostreambuf(m_ostr.rdbuf());\n"
   "         MY(ostr)->rdbuf(MY(xcmp));\n"
   "      }\n"
   "      else if (newcmp != k_no_compression) {\n"
   "         throw std::runtime_error(\"hddm_"
                      << classPrefix << "::ostream::configure_streambufs error - \"\n"
   "                                  \"unrecognized compression flag requested.\");\n"
   "      }\n"
   "   }\n"
   "   MY(status_bits) = m_status_bits;\n"
   "}\n"
   "\n"
   "void ostream::lock_streambufs() {\n"
   "   MY_SETUP\n"
   "   if (MY(mutex_lock) != 0) {\n"
   "      unlock_streambufs();\n"
   "      throw std::runtime_error(\"hddm_"
                      << classPrefix << "::ostream::lock_streambufs error - \"\n"
   "                               \"mutex lock requested when lock already held.\");\n"
   "   }\n"
   "   if ((MY(status_bits) & k_bits_compression) == k_no_compression) {\n"
   "      pthread_mutex_lock(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 1;\n"
   "   }\n"
   "   else if ((MY(status_bits) & k_bits_compression) == k_z_compression) {\n"
   "      ((xstream::z::ostreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 2;\n"
   "   }\n"
   "   else if ((MY(status_bits) & k_bits_compression) == k_bz2_compression) {\n"
   "      ((xstream::bz::ostreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);\n"
   "      MY(mutex_lock) = 3;\n"
   "   }\n"
   "   else {\n"
   "      MY(mutex_lock) = -1;\n"
   "   }\n"
   "}\n"
   "\n"
   "void ostream::unlock_streambufs() {\n"
   "   MY_SETUP\n"
   "   if (MY(mutex_lock) == 0) {\n"
   "      throw std::runtime_error(\"hddm_"
                << classPrefix << "::ostream::unlock_streambufs error - \"\n"
   "                               \"mutex unlock requested when lock not held.\");\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 1) {\n"
   "      pthread_mutex_unlock(&m_streambuf_mutex);\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 2) {\n"
   "      ((xstream::z::ostreambuf*)MY(xcmp))->set_streambuf_mutex(0);\n"
   "   }\n"
   "   else if (MY(mutex_lock) == 3) {\n"
   "      ((xstream::bz::ostreambuf*)MY(xcmp))->set_streambuf_mutex(0);\n"
   "   }\n"
   "   MY(mutex_lock) = 0;\n"
   "}\n"
   "\n"
   "int istream::getTag(const std::string &src, int start,\n"
   "                    std::string &tag, int &level)\n"
   "{\n"
   "   tag = \"\";\n"
   "   size_t p_btag = src.find(\"<\",start);\n"
   "   size_t p_bline = src.find_last_of(\"\\n\",p_btag);\n"
   "   if (p_bline == std::string::npos)\n"
   "   {\n"
   "      p_bline = 0;\n"
   "   }\n"
   "   else\n"
   "   {\n"
   "      ++p_bline;\n"
   "   }\n"
   "   level = (p_btag-p_bline)/2;\n"
   "   size_t p_etag = p_btag;\n"
   "   for (size_t quotes=0; p_etag < src.size(); ++p_etag) {\n"
   "      if (src[p_etag] == '\"') {\n"
   "         tag += \"\\\"\";\n"
   "         ++quotes;\n"
   "      }\n"
   "      else if (quotes/2*2 != quotes) {\n"
   "         tag += src[p_etag];\n"
   "      }\n"
   "      else if (src.find_first_of(\" \\t\\n\",p_etag) == 0) {\n"
   "         tag += \" \";\n"
   "         p_etag = src.find_first_not_of(\" \\t\\n\",p_etag)-1;\n"
   "      }\n"
   "      else if (src[p_etag] == '>') {\n"
   "         tag += \">\";\n"
   "         break;\n"
   "      }\n"
   "      else {\n"
   "         tag += src[p_etag];\n"
   "      }\n"
   "   }\n"
   "   if (p_etag == src.size()) {\n"
   "      std::stringstream sstr;\n"
   "      sstr << \"hddm_" + classPrefix + "::istream::getTag\"\n"
   "           << \" error - bad header format\" << std::endl\n"
   "           << \"   tag \" << tag << \" at position \" << start\n"
   "           << std::endl;\n"
   "      throw std::runtime_error(sstr.str());\n"
   "   }\n"
   "   return p_etag+2;\n"
   "}\n"
   "\n"
   "int istream::getEndTag(const std::string &src, int start,\n"
   "                       const std::string &tag)\n"
   "{\n"
   "   if (tag.rfind(\"/>\") == tag.size()-2) {\n"
   "      return src.find(tag,start) + tag.size()+1;\n"
   "   }\n"
   "   else {\n"
   "      std::string etag = \"</\";\n"
   "      etag += tag.substr(1,tag.find_first_of(' ')-1) + \">\";\n"
   "      size_t p_etag = src.find(etag,start);\n"
   "      size_t p_quote = src.find_first_of('\"',start);\n"
   "      while (p_quote != std::string::npos && p_quote < p_etag) {\n"
   "         p_quote = src.find_first_of('\"',p_quote+1);\n"
   "         if (p_quote > p_etag) {\n"
   "            p_etag = src.find(etag,p_quote+1);\n"
   "         }\n"
   "         p_quote = src.find_first_of('\"',p_quote+1);\n"
   "      }\n"
   "      if (p_etag == std::string::npos) {\n"
   "         std::stringstream sstr;\n"
   "         sstr << \"hddm_" + classPrefix + "::istream::getEndTag\"\n"
   "              << \" error - bad header format\" << std::endl\n"
   "              << \"   tag \" << tag << \" at position \" << start\n"
   "              << std::endl\n"
   "              << \"   end tag \" << etag << \" not found.\"\n"
   "              << std::endl;\n"
   "         throw std::runtime_error(sstr.str());\n"
   "      }\n"
   "      return p_etag + etag.size()+1;\n"
   "   }\n"
   "}\n"
   "\n"
   "void istream::collide(const std::string &itag, const std::string &rtag) {\n"
   "   std::string itagname = itag.substr(1,itag.find(\" \")-1);\n"
   "   std::string rtagname = rtag.substr(1,rtag.find(\" \")-1);\n"
   "   std::string errmsg = \"hddm_" + classPrefix +
   "::istream::collide warning:\\n\"\n"
   "         \"tag \" + itagname + \" in input file \"\n"
   "         \"does not match c++ header hddm_" << classPrefix << ".hpp\\n\"\n"
   "         \"  input file: \" + itag + \"\\n\"\n"
   "         \"  c++ header: \" + rtag + \"\\n\"\n"
   "         \"  === Tag \" + itagname + \" will be ignored,\"\n"
   "         \" rebuild to cure the problem ===\";\n"
   "   if (itagname != \"HDDM\") {\n"
   "      std::cerr << errmsg << std::endl;\n"
   "   }\n"
   "   else {\n"
   "      throw std::runtime_error(errmsg);\n"
   "   }\n"
   "}\n"
   "\n"
   "chromosome istream::synthesize(const std::string &src, int p_src,\n"
   "                               const std::string &ref, int p_ref)\n"
   "{\n"
   "   chromosome chrom;\n"
   "   int slevel, rlevel;\n"
   "   std::string stag, rtag;\n"
   "   p_src = getTag(src,p_src,stag,slevel);\n"
   "   p_ref = getTag(ref,p_ref,rtag,rlevel);\n"
   "   std::string stagname = stag.substr(1,stag.find(\" \")-1);\n"
   "   std::string rtagname = rtag.substr(1,rtag.find(\" \")-1);\n"
   "   if (stagname != rtagname) {\n"
   "      throw std::runtime_error(\"hddm_" + classPrefix +
   "::istream::synthesize error - matching algorithm error #2\");\n"
   "   }\n"
   "   else if (!tags_match(stag,rtag)) {\n"
   "      collide(stag,rtag);\n"
   "      return chrom;\n"
   "   }\n"
   "\n"
   "   int p2_src, p2_ref;\n"
   "   int s2level, r2level;\n"
   "   std::string s2tag, r2tag;\n"
   "   getTag(src,p2_src=p_src,s2tag,s2level);\n"
   "   while (s2level > slevel) {\n"
   "      codon *gene = new codon();\n"
   "      std::string s2tagname = s2tag.substr(1,s2tag.find(\" \")-1);\n"
   "      getTag(ref,p2_ref=p_ref,r2tag,r2level);\n"
   "      int order_of_this_tag_in_ref = 1;\n"
   "      while (r2level == s2level) {\n"
   "         std::string r2tagname = r2tag.substr(1,r2tag.find(\" \")-1);\n"
   "         if (s2tagname == r2tagname) {\n"
   "            if (!tags_match(s2tag,r2tag)) {\n"
   "               collide(s2tag,r2tag);\n"
   "               break;\n"
   "            }\n"
   "            else {\n"
   "               gene->m_order = order_of_this_tag_in_ref;\n"
   "            }\n"
   "            gene->m_sequence = synthesize(src,p2_src,ref,p2_ref);\n"
   "            break;\n"
   "         }\n"
   "         p2_ref = getEndTag(ref,p2_ref,r2tag);\n"
   "         getTag(ref,p2_ref,r2tag,r2level);\n"
   "         ++order_of_this_tag_in_ref;\n"
   "      }\n"
   "      gene->m_tagname = s2tagname;\n"
   "      chrom.push_back(*gene);\n"
   "      delete gene;\n"
   "      p2_src = getEndTag(src,p2_src,s2tag);\n"
   "      getTag(src,p2_src,s2tag,s2level);\n"
   "   }\n"
   "   return chrom;\n"
   "}\n"
   "\n"
   "#ifdef HDF5_SUPPORT\n"
   "std::map<std::string, hid_t> HDDM::s_hdf5_datatype;\n"
   "std::map<std::string, hid_t> HDDM::s_hdf5_memorytype;\n"
   "std::map<std::string, hid_t> HDDM::s_hdf5_memoryspace;\n"
   "std::map<hid_t, hid_t> HDDM::s_hdf5_dataspace;\n"
   "std::map<hid_t, hid_t> HDDM::s_hdf5_chunking;\n"
   "std::map<hid_t, hid_t> HDDM::s_hdf5_dataset;\n"
   "#endif\n"
   ;

   XMLPlatformUtils::Terminate();
   return 0;
}

XtString XtString::plural()
{
   XtString p(*this);
   XtString::size_type len = p.size();
   if (len > 3 && p.substr(len-3,3) == "tum")
   {
      p.replace(len-3,3,"ta");
   }
   else if (len > 1 && p.substr(len-3,3) == "ies")
   {
      p.replace(len-3,3,"iesList");
   }
   else if (len > 2 && p.substr(len-2,2) == "ex")
   {
      p.replace(len-2,2,"ices");
   }
   else if (len > 2 && p.substr(len-2,2) == "sh")
   {
      p.replace(len-2,2,"shes");
   }
   else if (len > 1 && p.substr(len-1,1) == "s")
   {
      p.replace(len-1,1,"ses");
   }
   else if (len > 1)
   {
      p += "s";
   }
   return p;
}

/* Map from tag name to name of the corresponding class
 * for the case of simple tags (those that do not repeat)
 */
XtString XtString::simpleType()
{
   XtString p(*this);
   p[0] = toupper(p[0]);
   return p;
}

/* Map from tag name to name of the corresponding class
 * for the case of list tags (those that may repeat)
 */
XtString XtString::listType()
{
   XtString r(*this);
   r[0] = toupper(r[0]);
   r = r + "List";
   return r;
}

/* Map from tag name to name of the corresponding class
 * for the case of link tags (those that do not repeat)
 */
XtString XtString::linkType()
{
   XtString r(*this);
   r[0] = toupper(r[0]);
   r = r + "Link";
   return r;
}

/* Look for a named element in a list of element pointers
 * and return index of first instance in the list if found,
 * otherwise return -1;
 */
int CodeBuilder::element_in_list(XtString &name, parentList_t list)
{
   int n=0;
   parentList_t::iterator iter;
   for (iter = list.begin(); iter != list.end(); ++iter, ++n)
   {
      DOMElement *el = (DOMElement*)(*iter);
      XtString cnameS(el->getTagName());
      if (cnameS == name) {
         return n;
      }
   }
   return -1;
}

/* Verify that the tag group under this element does not collide
 * with existing tag group elref, otherwise exit with fatal error
 */
void CodeBuilder::checkConsistency(DOMElement* el, DOMElement* elref)
{
   XtString tagS(el->getTagName());
   if (el->getParentNode() == elref->getParentNode())
   {
      std::cerr
           << "hddm-cpp error: tag " << "\"" << tagS 
           << "\" is duplicated within one context in xml document."
	   << std::endl;
      exit(1);
   }

   DOMNamedNodeMap* oldAttr = elref->getAttributes();
   DOMNamedNodeMap* newAttr = el->getAttributes();
   unsigned int listLength = oldAttr->getLength();
   for (unsigned int n = 0; n < listLength; n++)
   {
      XtString nameS(oldAttr->item(n)->getNodeName());
      XtString oldS(elref->getAttribute(X(nameS)));
      XtString newS(el->getAttribute(X(nameS)));
      if (nameS == "minOccurs")
      {
         continue;
      }
      else if (nameS == "maxOccurs")
      {
         int maxold = (oldS == "unbounded")? INT_MAX : atoi(S(oldS));
         int maxnew = (newS == "unbounded")? INT_MAX : atoi(S(newS));
	 if ((maxold < 2 && maxnew > 1) || (maxold > 1 && maxnew < 2))
         {
            std::cerr
                 << "hddm-cpp error: inconsistent maxOccurs usage by tag "
                 << "\"" << tagS << "\" in xml document." << std::endl;
            exit(1);
         }
      }
      else if (newS != oldS)
      {
         std::cerr
              << "hddm-cpp error: inconsistent usage of attribute "
              << "\"" << nameS << "\" in tag "
              << "\"" << tagS << "\" in xml document." << std::endl;
         exit(1);
      }
   }
   listLength = newAttr->getLength();
   for (unsigned int n = 0; n < listLength; n++)
   {
      XtString nameS(newAttr->item(n)->getNodeName());
      XtString oldS(elref->getAttribute(X(nameS)));
      XtString newS(el->getAttribute(X(nameS)));
      if (nameS == "minOccurs")
      {
         continue;
      }
      else if (nameS == "maxOccurs")
      {
         int maxold = (oldS == "unbounded")? INT_MAX : atoi(S(oldS));
         int maxnew = (newS == "unbounded")? INT_MAX : atoi(S(newS));
	 if ((maxold < 2 && maxnew > 1) || (maxold > 1 && maxnew < 2))
         {
            std::cerr
                 << "hddm-cpp error: inconsistent maxOccurs usage by tag "
                 << "\"" << tagS << "\" in xml document." << std::endl;
            exit(1);
         }
      }
      else if (newS != oldS)
      {
         std::cerr
              << "hddm-cpp error: inconsistent usage of attribute "
              << "\"" << nameS << "\" in tag "
              << "\"" << tagS << "\" in xml document." << std::endl;
         exit(1);
      }
   }
   DOMNodeList* oldList = elref->getChildNodes();
   DOMNodeList* newList = el->getChildNodes();
   listLength = oldList->getLength();
   if (newList->getLength() != listLength)
   {
      std::cerr
           << "hddm-cpp error: inconsistent usage of tag "
           << "\"" << tagS << "\" in xml document." << std::endl;
   exit(1);
   }
   for (unsigned int n = 0; n < listLength; n++)
   {
      DOMNode* cont = oldList->item(n);
      XtString nameS(cont->getNodeName());
      short type = cont->getNodeType();
      if (type == DOMNode::ELEMENT_NODE)
      {
         DOMNodeList* contList = el->getElementsByTagName(X(nameS));
         if (contList->getLength() != 1)
         {
             std::cerr
                  << "hddm-cpp error: inconsistent usage of tag "
                  << "\"" << tagS << "\" in xml document." << std::endl;
             exit(1);
         }
      }
   }
}

/* Write declaration of the classes for this tag to the header file */

void CodeBuilder::writeClassdef(DOMElement* el)
{
   XtString tagS(el->getTagName());
   hFile << "class " << tagS.simpleType()
         << ": public HDDM_Element {" << std::endl
         << " public:" << std::endl;
   if (tagS == "HDDM") {
      hFile << "   HDDM();" << std::endl;
   }
   hFile << "   ~" << tagS.simpleType() << "();" << std::endl;
   hFile << "   void clear();" << std::endl;

   std::map<XtString,XtString> attrList;
   DOMNamedNodeMap *myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      attrList[attrS] = typeS;
   }
   parentList_t::iterator iter;
   for (iter = parents[tagS].begin(); iter != parents[tagS].end(); ++iter)
   {
      DOMElement *hostEl = (DOMElement*)(*iter);
      XtString hostS(hostEl->getTagName());
      DOMNamedNodeMap *hostAttr = hostEl->getAttributes();
      for (unsigned int n = 0; n < hostAttr->getLength(); n++)
      {
         XtString attrS(hostAttr->item(n)->getNodeName());
         if (attrList.find(attrS) != attrList.end())
         {
            continue;
         }
         XtString typeS(hostEl->getAttribute(X(attrS)));
         attrList[attrS] = typeS;
         XtString getS("get"+attrS.simpleType());
         if (typeS == "int")
         {
            hFile << "   int " << getS << "() const;" << std::endl;
         }
         else if (typeS == "long")
         {
            hFile << "   int64_t " << getS << "() const;" << std::endl;
         }
         else if (typeS == "float")
         {
            hFile << "   float " << getS << "() const;" << std::endl;
         }
         else if (typeS == "double")
         {
            hFile << "   double " << getS << "() const;" << std::endl;
         }
         else if (typeS == "boolean")
         {
            hFile << "   bool " << getS << "() const;" << std::endl;
         }
         else if (typeS == "string")
         {
            hFile << "   std::string " << getS << "() const;" << std::endl;
         }
         else if (typeS == "anyURI")
         {
            hFile << "   std::string " << getS << "() const;" << std::endl;
         }
         else if (typeS == "Particle_t")
         {
            hFile << "   Particle_t " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "int")
         {
            hFile << "   int " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "long")
         {
            hFile << "   int64_t " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "float")
         {
            hFile << "   float " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "double")
         {
            hFile << "   double " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "boolean")
         {
            hFile << "   bool " << getS << "() const;" << std::endl;
         }
         else if (guessType(typeS) == "Particle_t")
         {
            hFile << "   Particle_t " << getS << "() const;" << std::endl;
         }
         else /* any values not matching the above are strings */
         {
            hFile << "   std::string " << getS << "() const;" << std::endl;
         }
      }
   }

   myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      XtString getS("get" + attrS.simpleType());
      XtString setS("set" + attrS.simpleType());
      if (typeS == "int")
      {
         hFile << "   int " << getS << "() const;" << std::endl
               << "   void " << setS << "(int " << attrS << ");" << std::endl;
      }
      else if (typeS == "long")
      {
         hFile << "   int64_t " << getS << "() const;" << std::endl
               << "   void " << setS << "(int64_t " << attrS << ");" << std::endl;
      }
      else if (typeS == "float")
      {
         hFile << "   float " << getS << "() const;" << std::endl
               << "   void " << setS << "(float " << attrS << ");" << std::endl;
      }
      else if (typeS == "double")
      {
         hFile << "   double " << getS << "() const;" << std::endl
               << "   void " << setS << "(double " << attrS << ");" << std::endl;
      }
      else if (typeS == "boolean")
      {
         hFile << "   bool " << getS << "() const;" << std::endl
               << "   void " << setS << "(bool " << attrS << ");" << std::endl;
      }
      else if (typeS == "string")
      {
         hFile << "   std::string " << getS << "() const;" << std::endl
               << "   void " << setS << "(const std::string &" << attrS << ");"
               << std::endl;
      }
      else if (typeS == "anyURI")
      {
         hFile << "   std::string " << getS << "() const;" << std::endl
               << "   void " << setS << "(const std::string &" << attrS << ");"
               << std::endl;
      }
      else if (typeS == "Particle_t")
      {
         hFile << "   Particle_t " << getS << "() const;" << std::endl
               << "   void " << setS << "(Particle_t " << attrS << ");" << std::endl;
      }
      else if (guessType(typeS) == "int")
      {
         hFile << "   int " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "long")
      {
         hFile << "   int64_t " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "float")
      {
         hFile << "   float " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "double")
      {
         hFile << "   double " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "boolean")
      {
         hFile << "   bool " << getS << "() const;" << std::endl;
      }
      else if (guessType(typeS) == "Particle_t")
      {
         hFile << "   Particle_t " << getS << "() const;" << std::endl;
      }
      else /* any attributes not matching the above are strings */
      {
         hFile << "   std::string " << getS << "() const;" << std::endl;
      }
   }

   if (tagS == "HDDM") {
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString cnameS(piter->first);
         if (cnameS != "HDDM" && element_in_list(cnameS,children[tagS]) == -1)
         {
            hFile << "   " << cnameS.listType() << " get"
                  << cnameS.plural().simpleType() << "();" << std::endl;
         }
      }
   }

   parentList_t::iterator citer;
   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      hFile << "   " << cnameS.simpleType() << " &get"
            << cnameS.simpleType()
            << ((rep > 1)? "(int index=0);" : "();") << std::endl;
      hFile << "   " << cnameS.listType() << " &get" 
            << cnameS.plural().simpleType() << "();" << std::endl;
      hFile << "   " << cnameS.listType() << " add"
            << cnameS.plural().simpleType()
            << "(int count=1, int start=-1);" << std::endl;
      hFile << "   void delete"
            << cnameS.plural().simpleType()
            << "(int count=-1, int start=0);" << std::endl;
   }

   hFile << "   const void *getAttribute(const std::string &name,"
         << " hddm_type *atype=0) const;\n"
         << "   std::string toString(int indent=0);\n"
         << "   std::string toXML(int indent=0);\n";

   if (tagS == "HDDM")
   {
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString cnameS(piter->first);
         if (cnameS != "HDDM") {
            hFile << "   friend class " << cnameS.simpleType() << ";"
                  << std::endl;
         }
      }
      hFile << "   static std::string DocumentString();" << std::endl;
      hFile << " private:" << std::endl;
   }
   else
   {
      hFile << "#ifdef HDF5_SUPPORT" << std::endl
            << "   void hdf5DataPack();" << std::endl
            << "   void hdf5DataUnpack();" << std::endl
            << "   hid_t hdf5Datatype(int inmemory=0, int verbose=0);"
            << std::endl
            << "#endif" << std::endl;
      hFile << "   friend class HDDM_ElementList<"
            << tagS.simpleType() << ">;" << std::endl
            << "   friend class HDDM_ElementLink<"
            << tagS.simpleType() << ">;" << std::endl
            << "   " << tagS.simpleType() << "() {}" << std::endl
            << "   " << tagS.simpleType() 
            << "(HDDM_Element *parent, int owner=0);" << std::endl;
      hFile << " private:" << std::endl;
   }

   hFile << "   void streamer(istream &istr);" << std::endl
         << "   void streamer(ostream &ostr);" << std::endl;

   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "int")
      {
         hFile << "   int m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "long")
      {
         hFile << "   int64_t m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "float")
      {
         hFile << "   float m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "double")
      {
         hFile << "   double m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "boolean")
      {
         hFile << "   int m_" << attrS << ";" << std::endl;
      }
      else if (typeS == "string")
      {
         hFile << "   std::string m_" << attrS << ";" << std::endl;
         hFile << "   const char *mx_" << attrS << ";" << std::endl;
      }
      else if (typeS == "anyURI")
      {
         hFile << "   std::string m_" << attrS << ";" << std::endl;
         hFile << "   const char *mx_" << attrS << ";" << std::endl;
      }
      else if (typeS == "Particle_t")
      {
         hFile << "   int m_" << attrS << ";" << std::endl;
      }
   }

   if (tagS == "HDDM") {
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString dnameS(piter->first);
         if (dnameS != "HDDM") {
            hFile << "   std::list<" << dnameS.simpleType()
                  << "*> m_" << dnameS << "_plist;" << std::endl;
         }
      }
   }

   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      hFile << "   " << ((rep > 1)? cnameS.listType() : cnameS.linkType())
            << " m_" << cnameS
            << ((rep > 1)? "_list;" : "_link;") << std::endl;
   }

   if (tagS == "HDDM") {
      hFile << "#ifdef HDF5_SUPPORT" << std::endl
            << " public:" << std::endl
            << "   void hdf5DataPack();" << std::endl
            << "   void hdf5DataUnpack();" << std::endl
            << "   hid_t hdf5Datatype(int inmemory=0, int verbose=0);"
            << std::endl
            << "   herr_t hdf5FileWrite(hid_t file_id, long int entry=-1);"
            << std::endl
            << "   herr_t hdf5FileRead(hid_t file_id, long int entry=-1);"
            << std::endl
            << "   static hid_t"
            << " hdf5FileCreate(std::string name, unsigned int flags);"
            << std::endl
            << "   static hid_t"
            << " hdf5FileOpen(std::string name, unsigned int flags);"
            << std::endl
            << "   static herr_t hdf5FileClose(hid_t file_id);"
            << std::endl
            << "   static herr_t hdf5FileStamp(hid_t file_id, char **tags=0);"
            << std::endl
            << "   static herr_t hdf5FileCheck(hid_t file_id, char **tags=0);"
            << std::endl
            << "   static std::string hdf5DocumentString(hid_t file_id);"
            << std::endl
            << "   static long int hdf5GetEntries(hid_t file_id);"
            << std::endl
            << "   static herr_t hdf5SetChunksize(hid_t file_id,"
            << " hsize_t chunksize);"
            << std::endl
            << "   static hsize_t hdf5GetChunksize(hid_t file_id);"
            << std::endl
            << "   static herr_t hdf5SetFilters(hid_t file_id,"
            << " std::vector<H5Z_filter_t> &filters);"
            << std::endl
            << "   static herr_t hdf5GetFilters(hid_t file_id,"
            << " std::vector<H5Z_filter_t> &filters);"
            << std::endl
            << "   static void hdf5_memcpy(void *dst, void *src, int size) {"
            << std::endl
	    << "      memcpy(dst, src, size);"
            << std::endl
	    << "   }" << std::endl
            << " private:" << std::endl
            << "   static std::map<std::string, hid_t> s_hdf5_datatype;"
            << std::endl
            << "   static std::map<std::string, hid_t> s_hdf5_memorytype;"
            << std::endl
            << "   static std::map<std::string, hid_t> s_hdf5_memoryspace;"
            << std::endl
            << "   static std::map<hid_t, hid_t> s_hdf5_dataspace;"
            << std::endl
            << "   static std::map<hid_t, hid_t> s_hdf5_chunking;"
            << std::endl
            << "   static std::map<hid_t, hid_t> s_hdf5_dataset;"
            << std::endl
            << "   typedef struct {" << std::endl;
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString dnameS(piter->first);
         if (dnameS != "HDDM") {
            hFile << "      hdf5_hvl_t vl_" << dnameS << ";" 
                  << std::endl;
         }
      }
      hFile << "   } hdf5_record_t;" << std::endl
            << "   hdf5_record_t m_hdf5_record;" << std::endl
            << "   hsize_t m_hdf5_record_offset;" << std::endl
            << "   hsize_t m_hdf5_record_count;" << std::endl
            << "   hsize_t m_hdf5_record_extent;" << std::endl
            << "   std::vector<std::string*> m_hdf5_strings;"
            << std::endl
            << "#endif" << std::endl;
   }
   hFile << "};" << std::endl << std::endl;

   if (tagS != "HDDM")
   {
      hFile << "typedef HDDM_ElementList<"
            << tagS.simpleType() << "> "
            << tagS.listType() << ";" << std::endl
            << "typedef HDDM_ElementLink<"
            << tagS.simpleType() << "> "
            << tagS.linkType() << ";"
            << std::endl << std::endl;
   }
}

/* Generate class declarations for this tag and its descendants;
 * this function calls itself recursively
 */

void CodeBuilder::constructGroup(DOMElement* el)
{
   XtString tagS(el->getTagName());
   parentList_t::iterator piter;
   parents[tagS].insert(parents[tagS].begin(),
                        parentList.begin(),parentList.end());
   std::vector<DOMElement*>::iterator iter;
   for (iter = tagList.begin(); iter != tagList.end(); iter++)
   {
      DOMElement* targEl = *iter;
      XtString targS(targEl->getTagName());
      if (tagS == targS)
      {
         checkConsistency(el,targEl);
         return;
      }
   }

   parentList.push_back(el);
   DOMNodeList* contList = el->getChildNodes();
   int contLength = contList->getLength();
   for (int c = 0; c < contLength; c++)
   {
      DOMNode* cont = contList->item(c);
      short type = cont->getNodeType();
      if (type == DOMNode::ELEMENT_NODE)
      {
         DOMElement* contEl = (DOMElement*) cont;
         XtString contS(contEl->getTagName());
         children[tagS].push_back(contEl);
         constructGroup(contEl);
      }
   }
   parentList.pop_back();

   tagList.push_back(el);

   if (tagS == "HDDM")
   {
      std::vector<DOMElement*>::iterator iter;
      for (iter = tagList.begin(); iter != tagList.end(); iter++)
      {
         writeClassdef(*iter);
      }
   }
}

/* Write method implementation of the classes for this tag to the header file */

void CodeBuilder::writeClassimp(DOMElement* el)
{
   XtString tagS(el->getTagName());
   if (tagS == "HDDM")
   {
      hFile << "inline " << tagS.simpleType() << "::"
            << tagS.simpleType() << "()" << std::endl
            << " : HDDM_Element()";
   }
   else
   {
      hFile << "inline " << tagS.simpleType() << "::"
            << tagS.simpleType() << "(HDDM_Element *parent, int owner)"
            << std::endl
            << " : HDDM_Element(parent, owner)";
   }
   DOMNamedNodeMap *myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "int")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "long")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "float")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "double")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "boolean")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else if (typeS == "string")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(\"\")";
      }
      else if (typeS == "anyURI")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(\"\")";
      }
      else if (typeS == "Particle_t")
      {
         hFile << "," << std::endl << "   m_" << attrS << "(0)";
      }
      else
      {
         /* ignore attributes with unrecognized values */
      }
   }
	
	// Write XXX_plist initializers first and then the XXX_list or
	// XXX_link initializers. This is because the plist members
	// appear first in the class definition.
	// Dec. 3, 2012  David L.
   parentList_t::iterator citer;
   for (citer = children[tagS].begin();
        citer != children[tagS].end();
        ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      // int rep;  commented out to avoid compiler warnings 4/26/2015 DL
      // rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      XtString hostS("m_host->");
      if (tagS == "HDDM")
      {
         hFile << "," << std::endl << "   m_" << cnameS
               << "_plist()";
         hostS = "";
      }
   }
   for (citer = children[tagS].begin();
        citer != children[tagS].end();
        ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      const char *myHost = (tagS=="HDDM" ? "this->":"m_host->");
      XtString hostS(myHost);
      hFile << "," << std::endl << "   m_" << cnameS
            << ((rep > 1)? "_list" : "_link")
            << "(&" << hostS << "m_" << cnameS << "_plist," << std::endl
            << "               "
            << hostS << "m_" << cnameS << "_plist.end()," << std::endl
            << "               "
            << hostS << "m_" << cnameS << "_plist.end()," << std::endl
            << "               "
            << "this)";
   }
   if (tagS == "HDDM")
   {
      hFile << std::endl << "{" << std::endl
            << "   m_host = this;" << std::endl
            << "#ifdef HDF5_SUPPORT" << std::endl
            << "   m_hdf5_record_offset = 0;" << std::endl
            << "   m_hdf5_record_count = 0;" << std::endl
            << "   m_hdf5_record_extent = 0;" << std::endl
            << "#endif" << std::endl
            << "}" << std::endl << std::endl;
   }
   else
   {
      hFile << std::endl << "{}" << std::endl << std::endl;
   }

   hFile << "inline " << tagS.simpleType() << "::~"
         << tagS.simpleType() << "() {" << std::endl
         << "   clear();" << std::endl
         << "}" << std::endl;
   if (tagS != "HDDM")
   {
      hFile << "inline void " << tagS.simpleType() 
            << "::clear() {";
      if (children[tagS].size() > 0) {
         hFile << std::endl
               << "   if (m_host != 0) {" << std::endl;
         for (citer = children[tagS].begin();
              citer != children[tagS].end();
              ++citer)
         {
            DOMElement *childEl = (DOMElement*)(*citer);
            XtString cnameS(childEl->getTagName());
            hFile << "   delete" << cnameS.plural().simpleType()
                  << "();" << std::endl;
         }
         hFile << "   }" << std::endl;
      }
      hFile << "}" << std::endl << std::endl;
   }

   std::map<XtString,XtString> attrList;
   myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      attrList[attrS] = typeS;
   }
   parentList_t::iterator iter;
   for (iter = parents[tagS].begin(); iter != parents[tagS].end(); ++iter)
   {
      DOMElement *hostEl = (DOMElement*)(*iter);
      DOMNamedNodeMap *hostAttr = hostEl->getAttributes();
      for (unsigned int n = 0; n < hostAttr->getLength(); n++)
      {
         XtString attrS(hostAttr->item(n)->getNodeName());
         if (attrList.find(attrS) != attrList.end())
         {
            continue;
         }
         XtString typeS(hostEl->getAttribute(X(attrS)));
         attrList[attrS] = typeS;
         XtString getS("get" + attrS.simpleType());
         if (typeS == "int")
         {
            hFile << "inline int " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(int*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "long")
         {
            hFile << "inline int64_t " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(int64_t*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "float")
         {
            hFile << "inline float " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(float*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "double")
         {
            hFile << "inline double " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(double*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "boolean")
         {
            hFile << "inline bool " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(bool*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "string")
         {
            hFile << "inline std::string " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(const std::string*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "anyURI")
         {
            hFile << "inline std::string " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(const std::string*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (typeS == "Particle_t")
         {
            hFile << "inline Particle_t " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(Particle_t*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "int")
         {
            hFile << "inline int " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(int*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "long")
         {
            hFile << "inline int64_t " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(long long int*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "float")
         {
            hFile << "inline float " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(float*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "double")
         {
            hFile << "inline double " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(double*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "boolean")
         {
            hFile << "inline bool " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(bool*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else if (guessType(typeS) == "Particle_t")
         {
            hFile << "inline Particle_t " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(Particle_t*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
         else /* any attributes not of the above types are strings */
         {
            hFile << "inline std::string " << tagS.simpleType()
                  << "::" << getS << "() const {" << std::endl
                  << "   return *(std::string*)m_parent->getAttribute(\""
                  << attrS << "\");" << std::endl
                  << "}" << std::endl << std::endl;
         }
      }
   }

   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      XtString getS("get" + attrS.simpleType());
      XtString setS("set" + attrS.simpleType());
      if (typeS == "int")
      {
         hFile << "inline int " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(int " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "long")
      {
         hFile << "inline int64_t " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(int64_t " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "float")
      {
         hFile << "inline float " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(float " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "double")
      {
         hFile << "inline double " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(double " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "boolean")
      {
         hFile << "inline bool " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(bool " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "string")
      {
         hFile << "inline std::string " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(const std::string &" << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "anyURI")
      {
         hFile << "inline std::string " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(const std::string &" << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (typeS == "Particle_t")
      {
         hFile << "inline Particle_t " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return (Particle_t)m_" << attrS << ";" << std::endl
               << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::" << setS
               << "(Particle_t " << attrS << ") {" << std::endl
               << "   m_" << attrS << " = " << attrS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "int")
      {
         hFile << "inline int " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "long")
      {
         hFile << "inline int64_t " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << "LL;" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "float")
      {
         hFile << "inline float " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "double")
      {
         hFile << "inline double " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "boolean")
      {
         hFile << "inline bool " << tagS.simpleType() << "::" << getS
               << "() const {" << std::endl
               << "   return " << typeS << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else if (guessType(typeS) == "Particle_t")
      {
         hFile << "inline Particle_t " << tagS.simpleType()
               << "::" << getS << "() const {" << std::endl
               << "   return (Particle_t)" << lookupParticle(typeS)
               << ";" << std::endl
               << "}" << std::endl << std::endl;
      }
      else /* anything not listed above is classed as a string */
      {
         hFile << "inline std::string " << tagS.simpleType()
               << "::" << getS << "() const {" << std::endl
               << "   return \"" << typeS << "\";" << std::endl
               << "}" << std::endl << std::endl;
      }
   }

   if (tagS == "HDDM")
   {
      hFile << "inline void HDDM::clear() {" << std::endl;
      for (citer = children[tagS].begin();
           citer != children[tagS].end();
           ++citer)
      {
         DOMElement *childEl = (DOMElement*)(*citer);
         XtString cnameS(childEl->getTagName());
         hFile << "   delete" << cnameS.simpleType().plural()
               << "();" << std::endl;
      }
      hFile << "#ifdef HDF5_SUPPORT" << std::endl
            << "   if (m_hdf5_record_count > 0) {" << std::endl
            << "      for (unsigned i=0; i < m_hdf5_strings.size(); ++i) {"
            << std::endl
            << "         m_hdf5_strings[i]->std::string::~string();"
            << std::endl
            << "      }" << std::endl
            << "      m_hdf5_strings.clear();" << std::endl
            << "      H5Dvlen_reclaim(s_hdf5_memorytype[\"HDDM\"]," << std::endl
            << "                      s_hdf5_memoryspace[\"HDDM\"]," << std::endl
            << "                      H5P_DEFAULT, &m_hdf5_record);" << std::endl
            << "      m_hdf5_record_count = 0;" << std::endl
            << "   }" << std::endl
            << "#endif" << std::endl
            << "}" << std::endl << std::endl;
   }
   hFile << "inline const void *" << tagS.simpleType()
         << "::getAttribute(const std::string &name,\n"
         << "                                                   "
         << "hddm_type *atype) const {" << std::endl;
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      hFile << "   if (name == \"" << attrS << "\") {\n"
            << "      if (atype != 0)\n";
      if (typeS == "int")
      {
         hFile << "         *atype = k_hddm_int;\n";
      }
      else if (typeS == "long")
      {
         hFile << "         *atype = k_hddm_long;\n";
      }
      else if (typeS == "float")
      {
         hFile << "         *atype = k_hddm_float;\n";
      }
      else if (typeS == "double")
      {
         hFile << "         *atype = k_hddm_double;\n";
      }
      else if (typeS == "boolean")
      {
         hFile << "         *atype = k_hddm_boolean;\n";
      }
      else if (typeS == "string")
      {
         hFile << "         *atype = k_hddm_string;\n";
      }
      else if (typeS == "anyURI")
      {
         hFile << "         *atype = k_hddm_anyURI;\n";
      }
      else if (typeS == "Particle_t")
      {
         hFile << "         *atype = k_hddm_Particle_t;\n";
      }
      else if (guessType(typeS) == "int")
      {
         hFile << "         *atype = k_hddm_int;\n"
               << "      static int m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "long")
      {
         hFile << "         *atype = k_hddm_long;\n"
               << "      static long m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "float")
      {
         hFile << "         *atype = k_hddm_float;\n"
               << "      static float m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "double")
      {
         hFile << "         *atype = k_hddm_double;\n"
               << "      static double m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "boolean")
      {
         hFile << "         *atype = k_hddm_boolean;\n"
               << "      static int m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else if (guessType(typeS) == "Particle_t")
      {
         hFile << "         *atype = k_hddm_Particle_t;\n"
               << "      static Particle_t m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      else
      {
         hFile << "         *atype = k_hddm_unknown;\n"
               << "      static std::string m_" << attrS
               << " = get" << attrS.simpleType() << "();\n";
      }
      hFile << "      return &m_" << attrS << ";\n"
            << "   }\n";
   }
   if (tagS != "HDDM")
   {
      hFile << "   return m_parent->getAttribute(name, atype);" << std::endl;
   }
   else
   {
      hFile << "   return 0;" << std::endl;
   }
   hFile << "}" << std::endl << std::endl;

   cFile << "std::string " << tagS.simpleType()
         << "::toString(int indent) {\n"
         << "   std::stringstream ostr;\n"
         << "   for (int n=0; n < indent; ++n)\n"
         << "      ostr << \" \";\n"
         << "   ostr << \"" << tagS << "\"\n";
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "int" || typeS == "long" || 
          typeS == "float" || typeS == "double")
      {
	     cFile << "        << \" " << attrS << "=\" << "
               << "m_" << attrS << std::endl;
      }
      else if (typeS == "boolean")
      {
	     cFile << "        << \" " << attrS << "=\" << "
               << "((m_" << attrS << " == 0)? \"true\" : \"false\")"
               << std::endl;
      }
      else if (typeS == "string" || typeS == "anyURI")
      {
	     cFile << "        << \" " << attrS << "=\" << "
               << "\"\\\"\" << m_" << attrS << " << \"\\\"\"" << std::endl;
      }
      else if (typeS == "Particle_t")
      {
	     cFile << "        << \" " << attrS << "=\" << "
               << "ParticleType((Particle_t)m_" << attrS << ")" << std::endl;
      }
   }
   cFile << "             << std::endl;" << std::endl;
   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      if (rep > 1)
      {
         cFile << "   int " << cnameS.listType() << "Count=0;" << std::endl
               << "   for (" << cnameS.listType() << "::iterator it = "
               << "m_" << cnameS << "_list.begin();" << std::endl
               << "        it != "
               << "m_" << cnameS << "_list.end(); ++it)" << std::endl
               << "   {" << std::endl
               << "      if (++" << cnameS.listType() << "Count > "
               << "m_" << cnameS << "_list.size()) {" << std::endl
               << "         throw std::runtime_error(\"hddm_" 
                            << classPrefix << "::toString error - "
                           "list improperly terminated!\");" << std::endl
               << "      }" << std::endl
               << "      ostr << it->toString(indent + 2);" << std::endl
               << "   }" << std::endl;
      }
      else
      {
         cFile << "   if (! m_" << cnameS << "_link.empty()) {\n"
               << "      ostr << m_" << cnameS << "_link.begin()"
               << "->toString(indent + 2);\n"
               << "   }" << std::endl;
      }
   }
   cFile << "   return ostr.str();" << std::endl
         << "}" << std::endl << std::endl;

   cFile << "std::string " << tagS.simpleType()
         << "::toXML(int indent) {\n"
         << "   std::stringstream ostr;\n"
         << "   for (int n=0; n < indent; ++n)\n"
         << "      ostr << \" \";\n"
         << "   ostr << \"<" << tagS << "\"\n";
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (attrS == "minOccurs" || attrS == "maxOccurs")
      {
         continue;
      }
      if (typeS == "boolean")
      {
	     cFile << "        << \" " << attrS << "=\" << "
               << "((m_" << attrS << " == 0)? \"\\\"true\\\"\" : \"\\\"false\\\"\")"
               << std::endl;
      }
      else if (typeS == "Particle_t")
      {
	     cFile << "        << \" " << attrS << "=\\\"\" << "
               << "ParticleType((Particle_t)m_" << attrS << ") << \"\\\"\""
               << std::endl;
      }
      else
      {
	     cFile << "        << \" " << attrS << "=\" << "
               << "\"\\\"\" << get" << attrS.simpleType() 
               << "() << \"\\\"\"" << std::endl;
      }
   }
   if (children[tagS].size() > 0)
   {
       cFile << "        << \">\" << std::endl;" << std::endl;
   }
   else
   {
       cFile << "        << \" />\" << std::endl;" << std::endl;
   }
   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      if (rep > 1)
      {
         cFile << "   int " << cnameS.listType() << "Count=0;" << std::endl
               << "   for (" << cnameS.listType() << "::iterator it = "
               << "m_" << cnameS << "_list.begin();" << std::endl
               << "        it != "
               << "m_" << cnameS << "_list.end(); ++it)" << std::endl
               << "   {" << std::endl
               << "      if (++" << cnameS.listType() << "Count > "
               << "m_" << cnameS << "_list.size()) {" << std::endl
               << "         throw std::runtime_error(\"hddm_" 
                            << classPrefix << "::toXML error - "
                            "list improperly terminated!\");" << std::endl
               << "      }" << std::endl
               << "      ostr << it->toXML(indent + 2);" << std::endl
               << "   }" << std::endl;
      }
      else
      {
         cFile << "   if (! m_" << cnameS << "_link.empty()) {\n"
               << "      ostr << m_" << cnameS << "_link.begin()"
               << "->toXML(indent + 2);" << std::endl
               << "   }" << std::endl;
      }
   }
   if (children[tagS].size() > 0)
   {
      cFile << "   for (int n=0; n < indent; ++n)\n"
            << "      ostr << \" \";\n"
            << "   ostr << \"</" << tagS << ">\"\n"
            << "        << std::endl;" << std::endl;
   }
   cFile << "   return ostr.str();" << std::endl
         << "}" << std::endl << std::endl;

   cFile << "#ifdef HDF5_SUPPORT" << std::endl
         << "hid_t " << tagS.simpleType()
         << "::hdf5Datatype(int inmemory, int verbose)" << std::endl
         << "{" << std::endl
         << "   std::string tname(\"" << tagS << "\");" << std::endl
         << "   if (inmemory) {" << std::endl
         << "      if (HDDM::s_hdf5_memorytype.find(tname)"
         << " != HDDM::s_hdf5_memorytype.end())" << std::endl
         << "         return HDDM::s_hdf5_memorytype[tname];" << std::endl
         << "   }" << std::endl
         << "   else {" << std::endl
         << "      if (HDDM::s_hdf5_datatype.find(tname)"
         << " != HDDM::s_hdf5_datatype.end())" << std::endl
         << "         return HDDM::s_hdf5_datatype[tname];" << std::endl
         << "   }" << std::endl
         << "   hid_t tid = H5Tcreate(H5T_COMPOUND, sizeof(*this));"
         << std::endl
         << "   hid_t vl_string_tid = H5Tcopy(H5T_C_S1);" << std::endl
         << "   H5Tset_size(vl_string_tid, H5T_VARIABLE);" << std::endl;
   if (tagS != "HDDM") {
      for (unsigned int n = 0; n < myAttr->getLength(); n++)
      {
         XtString attrS(myAttr->item(n)->getNodeName());
         XtString typeS(el->getAttribute(X(attrS)));
         if (typeS == "int")
         {
            cFile << "   H5Tinsert(tid, \"" << attrS << "\", "
                  << "(char*)&m_" << attrS << " - (char*)this, "
                  << "((inmemory)? H5T_NATIVE_INT : H5T_STD_I32LE));"
                  << std::endl;
         }
         else if (typeS == "long")
         {
            cFile << "   H5Tinsert(tid, \"" << attrS << "\", "
                  << "(char*)&m_" << attrS << " - (char*)this, "
                  << "((inmemory)? H5T_NATIVE_LONG : H5T_STD_I64LE));"
                  << std::endl;
         }
         else if (typeS == "float")
         {
            cFile << "   H5Tinsert(tid, \"" << attrS << "\", "
                  << "(char*)&m_" << attrS << " - (char*)this, "
                  << "((inmemory)? H5T_NATIVE_FLOAT : H5T_IEEE_F32LE));"
                  << std::endl;
         }
         else if (typeS == "double")
         {
            cFile << "   H5Tinsert(tid, \"" << attrS << "\", "
                  << "(char*)&m_" << attrS << " - (char*)this, "
                  << "((inmemory)? H5T_NATIVE_DOUBLE : H5T_IEEE_F64LE));"
                  << std::endl;
         }
         else if (typeS == "boolean")
         {
            cFile << "   H5Tinsert(tid, \"" << attrS << "\", "
                  << "(char*)&m_" << attrS << " - (char*)this, "
                  << "((inmemory)? H5T_NATIVE_INT : H5T_STD_I32LE));"
                  << std::endl;
         }
         else if (typeS == "string")
         {
            cFile << "   H5Tinsert(tid, \"" << attrS << "\", "
                  << "(char*)&mx_" << attrS << " - (char*)this, "
                  << "vl_string_tid);"
                  << std::endl;
         }
         else if (typeS == "anyURI")
         {
            cFile << "   H5Tinsert(tid, \"" << attrS << "\", "
                  << "(char*)&mx_" << attrS << " - (char*)this, "
                  << "vl_string_tid);"
                  << std::endl;
         }
         else if (typeS == "Particle_t")
         {
            cFile << "   H5Tinsert(tid, \"" << attrS << "\", "
                  << "(char*)&m_" << attrS << " - (char*)this, "
                  << "((inmemory)? H5T_NATIVE_INT : H5T_STD_I32LE));"
                  << std::endl;
         }
      }
      for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
      {
         DOMElement *childEl = (DOMElement*)(*citer);
         XtString cnameS(childEl->getTagName());
         XtString repS(childEl->getAttribute(X("maxOccurs")));
         int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
         cFile << "   H5Tinsert(tid, \"" << cnameS.listType() << "_size\", "
               << "(char*)&m_" << cnameS
               << ((rep > 1)? "_list" : "_link") << ".m_size - (char*)this, "
               << "((inmemory)? H5T_NATIVE_INT : H5T_STD_I16LE));"
               << std::endl;
         cFile << "   H5Tinsert(tid, \"" << cnameS.listType() << "_offset\", "
               << "(char*)&m_" << cnameS
               << ((rep > 1)? "_list" : "_link") << ".m_ref - (char*)this, "
               << "((inmemory)? H5T_NATIVE_INT : H5T_STD_I16LE));"
               << std::endl;
      }
   }
   else {
      cFile << "   hid_t vl_tid;" << std::endl;
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString dnameS(piter->first);
         if (dnameS != "HDDM") {
            cFile << "   " << dnameS.simpleType()
                  << " l_" << dnameS << ";" << std::endl
                  << "   vl_tid = H5Tvlen_create(l_" << dnameS
                  << ".hdf5Datatype(inmemory));" << std::endl
                  << "   H5Tinsert(tid, \"vl_" << dnameS << "\", "
                  << "(char*)&m_hdf5_record.vl_" << dnameS
                  << " - (char*)&m_hdf5_record, vl_tid);"
                  << std::endl;
         }
      }
      cFile << "   if (inmemory == 0)" << std::endl
            << "      H5Tpack(tid);" << std::endl;
   }
   cFile << "   if (inmemory) {" << std::endl
         << "      HDDM::s_hdf5_memorytype[\"" << tagS << "\"] = tid;"
         << std::endl
         << "   }" << std::endl
         << "   else {" << std::endl
         << "      HDDM::s_hdf5_datatype[\"" << tagS << "\"] = tid;" << std::endl
         << "   }" << std::endl
         << "   if (verbose) {" << std::endl
         << "      size_t slen;" << std::endl
         << "      H5LTdtype_to_text(tid, 0, H5LT_DDL, &slen);" << std::endl
         << "      char *ddlstring = (char*)malloc(slen);" << std::endl
         << "      H5LTdtype_to_text(tid, ddlstring, H5LT_DDL, &slen);" << std::endl
         << "      if (inmemory)" << std::endl
         << "         printf(\"=== in-memory datatype %ld for %s is:\\n %s\\n\","
         << " tid, \"" << tagS << "\", ddlstring);" << std::endl
         << "      else" << std::endl
         << "         printf(\"=== on-disk datatype %ld for %s is:\\n %s\\n\","
         << " tid, \"" << tagS << "\", ddlstring);" << std::endl
         << "      free(ddlstring);" << std::endl
         << "   }" << std::endl
         << "   return tid;" << std::endl
         << "}" << std::endl;

   if (tagS == "HDDM") {
      cFile << "herr_t " << tagS.simpleType()
            << "::hdf5FileStamp(hid_t file_id, char **tags)" << std::endl
            << "{" << std::endl
            << "   std::string stamp(DocumentString());" << std::endl
            << "   while (tags != 0 && *tags != 0) {" << std::endl
            << "      stamp += \"<stamptag>\";" << std::endl
            << "      stamp += *tags;" << std::endl
            << "      stamp += \"</stamptag>\\n\";" << std::endl
            << "      ++tags;" << std::endl
            << "   }" << std::endl
            << "   hid_t stamp_tid = H5Tcopy(H5T_C_S1);" << std::endl
            << "   H5Tset_size(stamp_tid, H5T_VARIABLE);" << std::endl
            << "   hsize_t dims[1] = {1};" << std::endl
            << "   hsize_t maxdims[1] = {1};" << std::endl
            << "   hid_t stamp_sid = H5Screate_simple(1, dims, maxdims);"
            << std::endl
            << "   char *pstamp = (char*)stamp.c_str();"
            << std::endl
            << "   hid_t stamp_id ="
            << " H5Lexists(file_id, \"HDDMstamp\", H5P_DEFAULT);" << std::endl
            << "   if (stamp_id > 0) {" << std::endl
            << "      stamp_id = H5Dopen(file_id, \"HDDMstamp\","
            << " H5P_DEFAULT);" << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      stamp_id = H5Dcreate(file_id, \"HDDMstamp\","
            << std::endl
            << "                           stamp_tid, stamp_sid,"
            << std::endl
            << "                           H5P_DEFAULT, H5P_DEFAULT,"
            << std::endl
            << "                           H5P_DEFAULT);"
            << std::endl
            << "   }" << std::endl
            << "   herr_t res = H5Dwrite(stamp_id, stamp_tid,"
            << std::endl
            << "                         H5S_ALL, H5S_ALL,"
            << std::endl
            << "                         H5P_DEFAULT, &pstamp);"
            << std::endl
            << "   return res;" << std::endl
            << "}" << std::endl;
      cFile << "herr_t " << tagS.simpleType()
            << "::hdf5FileCheck(hid_t file_id, char **tags)" << std::endl
            << "{" << std::endl
            << "   char *pstamp;" << std::endl
            << "   hid_t stamp_id = H5Dopen(file_id, \"HDDMstamp\","
            << " H5P_DEFAULT);" << std::endl
            << "   hid_t stamp_sid = H5Dget_space(stamp_id);" << std::endl
            << "   hid_t stamp_tid = H5Dget_type(stamp_id);" << std::endl
            << "   stamp_tid = H5Tget_native_type(stamp_tid, H5T_DIR_DEFAULT);"
            << std::endl
            << "   herr_t res = H5Dread(stamp_id, stamp_tid," << std::endl
            << "                        H5S_ALL, H5S_ALL," << std::endl
            << "                        H5P_DEFAULT, &pstamp);" << std::endl
            << "   std::string sstamp(pstamp);" << std::endl
            << "   H5Dvlen_reclaim(stamp_tid, stamp_sid," << std::endl
            << "                   H5P_DEFAULT, &pstamp);" << std::endl
            << "   if (sstamp.find(DocumentString()) != 0) {" << std::endl
            << "      throw std::runtime_error(\"hddm_" 
            << classPrefix << "::hdf5FileCheck - \"" << std::endl
            << "                  \"HDF5 input record format mismatch!\");"
            << std::endl
            << "   }" << std::endl
            << "   while (tags != 0 && *tags != 0) {" << std::endl
            << "      std::string stag(\"<stamptag>\");" << std::endl
            << "      stag += *tags;" << std::endl
            << "      stag += \"</stamptag>\";" << std::endl
            << "      if (sstamp.find(stag) == sstamp.npos) {" << std::endl
            << "         throw std::runtime_error(\"hddm_" 
            << classPrefix << "::hdf5FileCheck - \"" << std::endl
            << "                  \"HDF5 input record tag is missing!\");"
            << std::endl
            << "      }" << std::endl
            << "      ++tags;" << std::endl
            << "   }" <<std::endl
            << "   H5Dclose(stamp_id);" << std::endl
            << "   return res;" << std::endl
            << "}" << std::endl;
      cFile << "std::string " << tagS.simpleType()
            << "::hdf5DocumentString(hid_t file_id)" << std::endl
            << "{" << std::endl
            << "   char *pstamp;" << std::endl
            << "   hid_t stamp_id = H5Dopen(file_id, \"HDDMstamp\","
            << " H5P_DEFAULT);" << std::endl
            << "   hid_t stamp_sid = H5Dget_space(stamp_id);" << std::endl
            << "   hid_t stamp_tid = H5Dget_type(stamp_id);" << std::endl
            << "   stamp_tid = H5Tget_native_type(stamp_tid, H5T_DIR_DEFAULT);"
            << std::endl
            << "   H5Dread(stamp_id, stamp_tid," << std::endl
            << "           H5S_ALL, H5S_ALL, H5P_DEFAULT, &pstamp);"
            << std::endl
            << "   std::string sstamp(pstamp);" << std::endl
            << "   H5Dvlen_reclaim(stamp_tid, stamp_sid," << std::endl
            << "                   H5P_DEFAULT, &pstamp);" << std::endl
            << "   H5Dclose(stamp_id);" << std::endl
            << "   return sstamp;" << std::endl
            << "}" << std::endl;
      cFile << "long int " << tagS.simpleType()
            << "::hdf5GetEntries(hid_t file_id)" << std::endl
            << "{" << std::endl
            << "   hid_t eventspace_id;" << std::endl
            << "   hid_t eventdata_id;" << std::endl
            << "   hid_t chunking_id;" << std::endl
            << "   htri_t exists ="
            << "   H5Lexists(file_id, \"HDDMevents\", H5P_DEFAULT);"
            << std::endl
            << "   if (exists <= 0)" << std::endl
            << "      return exists;" << std::endl
            << "   if (s_hdf5_dataset.find(file_id)"
            << " == s_hdf5_dataset.end()) {" << std::endl
            << std::endl
            << "      eventdata_id = H5Dopen(file_id, \"HDDMevents\","
            << std::endl
            << "                               H5P_DEFAULT);"
            << std::endl
            << "      chunking_id = H5Dget_create_plist(eventdata_id);"
            << std::endl
            << "      eventspace_id = H5Dget_space(eventdata_id);"
            << std::endl
            << "      s_hdf5_dataset[file_id] = eventdata_id;"
            << std::endl
            << "      s_hdf5_chunking[file_id] = chunking_id;"
            << std::endl
            << "      s_hdf5_dataspace[file_id] = eventspace_id;"
            << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      eventdata_id = s_hdf5_dataset[file_id];" << std::endl
            << "      chunking_id = s_hdf5_chunking[file_id];" << std::endl
            << "      eventspace_id = s_hdf5_dataspace[file_id];"
            << std::endl
            << "   }" << std::endl
            << "   hsize_t dims;" << std::endl
            << "   hsize_t maxdims;" << std::endl
            << "   H5Sget_simple_extent_dims(eventspace_id, &dims, &maxdims);"
            << std::endl
            << "   return dims;" << std::endl
            << "}" << std::endl;
      cFile << "herr_t " << tagS.simpleType() << "::hdf5SetChunksize"
            << "(hid_t file_id, hsize_t chunksize)" << std::endl
            << "{" << std::endl
            << "   hid_t chunking_id;" << std::endl
            << "   if (s_hdf5_chunking.find(file_id)"
            << " == s_hdf5_chunking.end()) {" << std::endl
            << "      chunking_id = H5Pcreate(H5P_DATASET_CREATE);"
            << std::endl
            << "      s_hdf5_chunking[file_id] = chunking_id;" << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      chunking_id = s_hdf5_chunking[file_id];" << std::endl
            << "   }" << std::endl
            << "   hsize_t chunks[1] = {chunksize};" << std::endl
            << "   return H5Pset_chunk(chunking_id, 1, chunks);" << std::endl
            << "}" << std::endl;
      cFile << "hsize_t " << tagS.simpleType() << "::hdf5GetChunksize"
            << "(hid_t file_id)" << std::endl
            << "{" << std::endl
            << "   if (s_hdf5_chunking.find(file_id)"
            << " == s_hdf5_chunking.end()) {" << std::endl
            << "      return HDF5_DEFAULT_CHUNK_SIZE;" << std::endl
            << "   }" << std::endl
            << "   hid_t chunking_id = s_hdf5_chunking[file_id];"
            << std::endl
            << "   hsize_t dims[1];" << std::endl
            << "   H5Pget_chunk(chunking_id, 1, dims);" << std::endl
            << "   return dims[0];" << std::endl
            << "}" << std::endl;
      cFile << "herr_t " << tagS.simpleType() << "::hdf5SetFilters"
            << "(hid_t file_id, std::vector<H5Z_filter_t> &filters)"
            << std::endl
            << "{" << std::endl
            << "   hid_t chunking_id;" << std::endl
            << "   if (s_hdf5_chunking.find(file_id)"
            << " == s_hdf5_chunking.end()) {" << std::endl
            << "      chunking_id = H5Pcreate(H5P_DATASET_CREATE);"
            << std::endl
            << "      s_hdf5_chunking[file_id] = chunking_id;" << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      chunking_id = s_hdf5_chunking[file_id];" << std::endl
            << "   }" << std::endl
            << "   for (auto filter : filters) {" << std::endl
            << "      if (filter == H5Z_FILTER_DEFLATE) {" << std::endl
            << "         H5Pset_deflate(chunking_id, 9);" << std::endl
            << "      }" << std::endl
            << "      else if (filter == H5Z_FILTER_SZIP) {" << std::endl
            << "         H5Pset_szip(chunking_id, H5_SZIP_NN_OPTION_MASK, 8);"
            << std::endl
            << "      }" << std::endl
            << "      else if (filter == H5Z_FILTER_SHUFFLE) {" << std::endl
            << "         H5Pset_shuffle(chunking_id);" << std::endl
            << "      }" << std::endl
            << "      else if (filter == H5Z_FILTER_SCALEOFFSET) {" << std::endl
            << "         H5Pset_scaleoffset(chunking_id, H5Z_SO_INT," << std::endl
            << "                            H5Z_SO_INT_MINBITS_DEFAULT);"
            << std::endl
            << "      }" << std::endl
            << "      else if (filter == H5Z_FILTER_NBIT) {" << std::endl
            << "         H5Pset_nbit(chunking_id);" << std::endl
            << "      }" << std::endl
            << "      else if (filter == H5Z_FILTER_FLETCHER32) {" << std::endl
            << "         H5Pset_fletcher32(chunking_id);" << std::endl
            << "      }" << std::endl
            << "      else {" << std::endl
            << "         unsigned int cd_values[] = {6};" << std::endl
            << "         H5Pset_filter(chunking_id, filter," << std::endl
            << "                       H5Z_FLAG_MANDATORY, (size_t)1, cd_values);"
            << "      }" << std::endl
            << std::endl
            << "   }" << std::endl
            << "   return 0;" << std::endl
            << "}" << std::endl;
      cFile << "herr_t " << tagS.simpleType() << "::hdf5GetFilters"
            << "(hid_t file_id, std::vector<H5Z_filter_t> &filters)"
            << std::endl
            << "{" << std::endl
            << "   filters.clear();" << std::endl
            << "   if (s_hdf5_chunking.find(file_id)"
            << " == s_hdf5_chunking.end()) {" << std::endl
            << "      return 0;" << std::endl
            << "   }" << std::endl
            << "   hid_t chunking_id = s_hdf5_chunking[file_id];"
            << std::endl
            << "   for (int i=0; i < H5Pget_nfilters(chunking_id); ++i) {"
            << std::endl
            << "      unsigned int flags;" << std::endl
            << "      size_t cd_nelmts = 9;" << std::endl
            << "      unsigned int cd_values[9];" << std::endl
            << "      size_t namelen = 99;" << std::endl
            << "      char name[99];" << std::endl
            << "      unsigned int filter_config;" << std::endl
            << "      filters.push_back(H5Pget_filter2(chunking_id, i,"
            << std::endl
            << "                        &flags, &cd_nelmts, cd_values,"
            << std::endl
            << "                        namelen, name, &filter_config));"
            << std::endl
            << "   }" << std::endl
            << "   return 0;" << std::endl
            << "}" << std::endl;
      cFile << "herr_t " << tagS.simpleType() << "::hdf5FileWrite"
            << "(hid_t file_id, long int entry)" << std::endl
            << "{" << std::endl
            << "   hdf5_record_t hdf5_record;" << std::endl
            << "   int size;\n" << std::endl
            << "   int len;\n" << std::endl;
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString dnameS(piter->first);
         if (dnameS != "HDDM") {
            cFile << "   if ((len = hdf5_record.vl_" << dnameS << ".len"
                  << " = m_" << dnameS << "_plist.size()) > 0) {"
                  << std::endl
                  << "      size = sizeof(" << dnameS.simpleType() << ");"
                  << std::endl
                  << "      hdf5_record.vl_" << dnameS << ".p"
                  << " = malloc(len * size);" << std::endl
                  << "      std::list<" << dnameS.simpleType() << "*>"
                  << "::iterator iter = m_" << dnameS << "_plist.begin();"
                  << std::endl
                  << "      " << dnameS.simpleType() << " *p = "
                  << "(" << dnameS.simpleType() << "*)hdf5_record.vl_"
                  << dnameS << ".p;" << std::endl
                  << "      for (int i=0; i < len; ++i, ++iter) {" << std::endl
                  << "         hdf5_memcpy(p+i, *iter, size);" << std::endl
                  << "         p[i].hdf5DataPack();" << std::endl
                  << "      }" << std::endl
                  << "   }" << std::endl;
         }
      }
      cFile << "   hid_t eventtype_id = hdf5Datatype();" << std::endl
            << "   hid_t memorytype_id = hdf5Datatype(1);" << std::endl
            << "   hid_t chunking_id;" << std::endl
            << "   if (s_hdf5_chunking.find(file_id)"
            << " == s_hdf5_chunking.end()) {" << std::endl
            << "      hdf5SetChunksize(file_id, HDF5_DEFAULT_CHUNK_SIZE);"
            << std::endl
            << "   }" << std::endl
            << "   chunking_id = s_hdf5_chunking[file_id];" << std::endl
            << "   hid_t memoryspace_id;" << std::endl
            << "   if (s_hdf5_memoryspace.find(\"HDDM\")"
            << " == s_hdf5_memoryspace.end()) {" << std::endl
            << "      hsize_t dims[1] = {1};" << std::endl
            << "      hsize_t maxdims[1] = {H5S_UNLIMITED};" << std::endl
            << "      memoryspace_id = H5Screate_simple(1, dims, maxdims);"
            << std::endl
            << "      s_hdf5_memoryspace[\"HDDM\"] = memoryspace_id;"
            << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      memoryspace_id = s_hdf5_memoryspace[\"HDDM\"];"
            << std::endl
            << "   }" << std::endl
            << "   hid_t eventspace_id;" << std::endl
            << "   if (s_hdf5_dataspace.find(file_id)"
            << " == s_hdf5_dataspace.end()) {" << std::endl
            << "      hsize_t dims[1] = {1};" << std::endl
            << "      hsize_t maxdims[1] = {H5S_UNLIMITED};" << std::endl
            << "      eventspace_id = H5Screate_simple(1, dims, maxdims);"
            << std::endl
            << "      s_hdf5_dataspace[file_id] = eventspace_id;" << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      eventspace_id = HDDM::s_hdf5_dataspace[file_id];"
            << std::endl
            << "   }" << std::endl
            << "   hid_t eventdata_id;" << std::endl
            << "   if (s_hdf5_dataset.find(file_id)"
            << " == s_hdf5_dataset.end()) {" << std::endl
            << std::endl
            << "      eventdata_id = H5Dcreate(file_id, \"HDDMevents\","
            << std::endl
            << "                               eventtype_id, eventspace_id,"
            << std::endl
            << "                               H5P_DEFAULT, chunking_id,"
            << std::endl
            << "                               H5P_DEFAULT);"
            << std::endl
            << "      s_hdf5_dataset[file_id] = eventdata_id;" << std::endl
            << "      m_hdf5_record_extent = 0;" << std::endl
            << "      m_hdf5_record_offset = 0;"
            << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      eventdata_id = s_hdf5_dataset[file_id];" << std::endl
            << "      hsize_t maxdims;" << std::endl
            << "      H5Sget_simple_extent_dims(eventspace_id,"
            << " &m_hdf5_record_extent, &maxdims);" << std::endl
            << "      H5Sget_select_bounds(eventspace_id,"
            << " &m_hdf5_record_offset, &maxdims);" << std::endl
            << "      ++m_hdf5_record_offset;" << std::endl
            << "   }" << std::endl
            << "   if (entry >= 0) {" << std::endl
            << "      m_hdf5_record_offset = entry;" << std::endl
            << "   }" << std::endl
            << "   if (m_hdf5_record_offset >= m_hdf5_record_extent) {"
            << std::endl
            << "      m_hdf5_record_extent = m_hdf5_record_offset + 1;"
            << std::endl
            << "      H5Dset_extent(eventdata_id, &m_hdf5_record_extent);"
            << std::endl
            << "      H5Sclose(eventspace_id);"
            << std::endl
            << "      eventspace_id = H5Dget_space(eventdata_id);"
            << std::endl 
            << "      s_hdf5_dataspace[file_id] = eventspace_id;"
            << std::endl 
            << "   }"
            << std::endl
            << "   hsize_t hdf5_record_count = 1;"
            << std::endl
            << "   H5Sselect_hyperslab(eventspace_id, H5S_SELECT_SET,"
            << std::endl
            << "                       &m_hdf5_record_offset, NULL,"
            << std::endl
            << "                       &hdf5_record_count, NULL);"
            << std::endl
            << "   herr_t res = H5Dwrite(eventdata_id, memorytype_id,"
            << std::endl
            << "                         memoryspace_id, eventspace_id,"
            << std::endl
            << "                         H5P_DEFAULT, &hdf5_record);"
            << std::endl;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString dnameS(piter->first);
         if (dnameS != "HDDM") {
            cFile << "   if ((len = hdf5_record.vl_" << dnameS << ".len"
                  << " = m_" << dnameS << "_plist.size()) > 0) {"
                  << std::endl
                  << "      free(hdf5_record.vl_" << dnameS << ".p);"
                  << std::endl
                  << "   }" << std::endl;
         }
      }
      cFile << "   return res;" << std::endl
            << "}" << std::endl;
      cFile << "herr_t " << tagS.simpleType() << "::hdf5FileRead"
            << "(hid_t file_id, long int entry)" << std::endl
            << "{" << std::endl
            << "   clear();" << std::endl
            << "   hid_t memorytype_id = hdf5Datatype(1);" << std::endl
            << "   hid_t memoryspace_id;" << std::endl
            << "   if (s_hdf5_memoryspace.find(\"HDDM\")"
            << " == s_hdf5_memoryspace.end()) {" << std::endl
            << "      hsize_t dims[1] = {1};" << std::endl
            << "      hsize_t maxdims[1] = {H5S_UNLIMITED};" << std::endl
            << "      memoryspace_id = H5Screate_simple(1, dims, maxdims);"
            << std::endl
            << "      s_hdf5_memoryspace[\"HDDM\"] = memoryspace_id;"
            << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      memoryspace_id = s_hdf5_memoryspace[\"HDDM\"];"
            << std::endl
            << "   }" << std::endl
            << "   hid_t eventdata_id;" << std::endl
            << "   hid_t chunking_id;" << std::endl
            << "   if (s_hdf5_dataset.find(file_id)"
            << " == s_hdf5_dataset.end()) {" << std::endl
            << std::endl
            << "      eventdata_id = H5Dopen(file_id, \"HDDMevents\","
            << std::endl
            << "                               H5P_DEFAULT);"
            << std::endl
            << "      chunking_id = H5Dget_create_plist(eventdata_id);"
            << std::endl
            << "      s_hdf5_dataset[file_id] = eventdata_id;"
            << "      s_hdf5_chunking[file_id] = chunking_id;"
            << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      eventdata_id = s_hdf5_dataset[file_id];" << std::endl
            << "      chunking_id = s_hdf5_chunking[file_id];"
            << std::endl
            << "   }" << std::endl
            << "   hid_t eventspace_id;" << std::endl
            << "   if (s_hdf5_dataspace.find(file_id)"
            << " == s_hdf5_dataspace.end()) {" << std::endl
            << "      eventspace_id = H5Dget_space(eventdata_id);" << std::endl
            << "      s_hdf5_dataspace[file_id] = eventspace_id;" << std::endl
            << "      hsize_t maxdims;" << std::endl
            << "      H5Sget_simple_extent_dims(eventspace_id,"
            << " &m_hdf5_record_extent, &maxdims);" << std::endl
            << "      m_hdf5_record_offset = 0;" << std::endl
            << "   }" << std::endl
            << "   else {" << std::endl
            << "      eventspace_id = HDDM::s_hdf5_dataspace[file_id];"
            << std::endl
            << "      hsize_t maxdims;" << std::endl
            << "      H5Sget_simple_extent_dims(eventspace_id,"
            << " &m_hdf5_record_extent, &maxdims);" << std::endl
            << "      H5Sget_select_bounds(eventspace_id,"
            << " &m_hdf5_record_offset, &maxdims);" << std::endl
            << "      ++m_hdf5_record_offset;" << std::endl
            << "   }" << std::endl
            << "   if (entry >= 0) {" << std::endl
            << "      m_hdf5_record_offset = entry;" << std::endl
            << "   }" << std::endl
            << "   if (m_hdf5_record_offset >= m_hdf5_record_extent)"
            << std::endl
            << "      return -1;" << std::endl
            << "   m_hdf5_record_count = 1;" << std::endl
            << "   H5Sselect_hyperslab(eventspace_id, H5S_SELECT_SET,"
            << std::endl
            << "                       &m_hdf5_record_offset, NULL,"
            << std::endl
            << "                       &m_hdf5_record_count, NULL);"
            << std::endl
            << "   herr_t res = H5Dread(eventdata_id, memorytype_id,"
            << std::endl
            << "                        memoryspace_id, eventspace_id,"
            << std::endl
            << "                        H5P_DEFAULT, &m_hdf5_record);"
            << std::endl
            << "   int len;" << std::endl;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString dnameS(piter->first);
         if (dnameS != "HDDM") {
            cFile << "   if ((len = m_hdf5_record.vl_" << dnameS << ".len)"
                  << " > 0) {" << std::endl
                  << "      " << dnameS.simpleType() << " *p ="
                  << "(" << dnameS.simpleType() << "*)"
                  << "m_hdf5_record.vl_" << dnameS << ".p;" << std::endl
                  << "      for (int i=0; i < len; ++i ) {" << std::endl
                  << "         m_" << dnameS << "_plist.push_back("
                  << "new(p+i) " << dnameS.simpleType() << ");"
                  << std::endl
                  << "      }" << std::endl
                  << "   }" << std::endl;
         }
      }
      for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
      {
         DOMElement *childEl = (DOMElement*)(*citer);
         XtString cnameS(childEl->getTagName());
         XtString repS(childEl->getAttribute(X("maxOccurs")));
         int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
         cFile << "   new(&m_" << cnameS << ((rep > 1)? "_list)" : "_link)")
               << " " << ((rep > 1)? cnameS.listType() : cnameS.linkType())
               << "(&m_" << cnameS << "_plist," << std::endl
               << "            m_" << cnameS << "_plist.begin()," << std::endl
               << "            m_" << cnameS << "_plist.end()," << std::endl
               << "            this);" << std::endl;
      }
      cFile << "   hdf5DataUnpack();" << std::endl
            << "   return res;" << std::endl
            << "}" << std::endl;
      cFile << "hid_t " << tagS.simpleType() << "::hdf5FileCreate("
            << "std::string name, unsigned int flags)" << std::endl
            << "{" << std::endl
            << "   hid_t file_id = H5Fcreate(name.c_str(), flags,"
            << " H5P_DEFAULT, H5P_DEFAULT);" << std::endl
            << "   hdf5FileStamp(file_id);" << std::endl
            << "   return file_id;" << std::endl
            << "}" << std::endl;
      cFile << "hid_t " << tagS.simpleType() << "::hdf5FileOpen("
            << "std::string name, unsigned int flags)" << std::endl
            << "{" << std::endl
            << "   hid_t file_id = H5Fopen(name.c_str(), flags, H5P_DEFAULT);"
            << std::endl
            << "   hdf5FileCheck(file_id);" << std::endl
            << "   return file_id;" << std::endl
            << "}" << std::endl;
      cFile << "herr_t " << tagS.simpleType() << "::hdf5FileClose("
            << "hid_t file_id)" << std::endl
            << "{" << std::endl
            << "   herr_t res = H5Fclose(file_id);" << std::endl
            << "   if (HDDM::s_hdf5_dataspace.find(file_id) !="
            << " HDDM::s_hdf5_dataspace.end()) {" << std::endl
            << "        H5Sclose(s_hdf5_dataspace[file_id]);" << std::endl
            << "        s_hdf5_dataspace.erase(file_id);" << std::endl
            << "   }" << std::endl
            << "   if (s_hdf5_chunking.find(file_id) !="
            << " s_hdf5_chunking.end()) {" << std::endl
            << "       H5Pclose(s_hdf5_chunking[file_id]);" << std::endl
            << "       s_hdf5_chunking.erase(file_id);" << std::endl
            << "   }" << std::endl
            << "   if (s_hdf5_dataset.find(file_id) !="
            << " s_hdf5_dataset.end()) {" << std::endl
            << "       H5Dclose(s_hdf5_dataset[file_id]);" << std::endl
            << "       s_hdf5_dataset.erase(file_id);" << std::endl
            << "   }" << std::endl
            << "   return res;" << std::endl
            << "}" << std::endl << std::endl;
   }
   cFile << "void " << tagS.simpleType() << "::hdf5DataPack()"
         << std::endl
         << "{" << std::endl;
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "string" || typeS == "anyURI")
      {
         cFile << "   mx_" << attrS << " = m_" << attrS << ".c_str();"
               << std::endl;
      }
   }
   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      cFile << "   m_"  << cnameS << ((rep > 1)? "_list" : "_link")
            << ".deflate();" << std::endl;
   }
   cFile << "}" << std::endl;
   cFile << "void " << tagS.simpleType() << "::hdf5DataUnpack()"
         << std::endl
         << "{" << std::endl;
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "string" || typeS == "anyURI")
      {
         cFile << "   new(&m_" << attrS << ") std::string();" << std::endl
               << "   if (mx_" << attrS << " != 0) {" << std::endl
               << "      m_" << attrS << " = mx_" << attrS << ";"
               << std::endl
               << "      m_host->m_hdf5_strings.push_back"
               << "(&m_" << attrS << ");" << std::endl
               << "   }" << std::endl;
      }
   }
   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      cFile << "   {" << std::endl
            << "      std::list<" << cnameS.simpleType() << "*> *host_plist ="
            << " &m_host->m_" << cnameS << "_plist;" << std::endl
            << "      m_"  << cnameS << ((rep > 1)? "_list" : "_link")
            << ".inflate(m_host, host_plist, this);" << std::endl
            << "      "  << cnameS.listType() << "::iterator iter;" << std::endl
            << "      for (iter = m_" << cnameS << ((rep > 1)? "_list" : "_link")
            << ".begin();" << std::endl
            << "           iter != m_" << cnameS << ((rep > 1)? "_list" : "_link")
            << ".end(); ++iter)" << std::endl
            << "      {" << std::endl
            << "         iter->hdf5DataUnpack();" << std::endl
            << "      }" << std::endl
            << "   }" << std::endl;
   }
   cFile << "}" << std::endl;

   cFile << "#endif" << std::endl << std::endl;

   for (citer = children[tagS].begin(); citer != children[tagS].end(); ++citer)
   {
      DOMElement *childEl = (DOMElement*)(*citer);
      XtString cnameS(childEl->getTagName());
      XtString repS(childEl->getAttribute(X("maxOccurs")));
      int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
      if (rep > 1)
      {
         hFile << "inline " << cnameS.simpleType() << " &"
               << tagS.simpleType() << "::get" << cnameS.simpleType()
               << "(int index) {" << std::endl
               << "   return m_" << cnameS << "_list(index);" << std::endl
               << "}" << std::endl << std::endl
               << "inline " << cnameS.listType() << " &" 
               << tagS.simpleType() << "::get" << cnameS.plural().simpleType()
               << "() {" << std::endl
               << "   return m_" << cnameS << "_list;" << std::endl
               << "}" << std::endl << std::endl
               << "inline " << cnameS.listType() << " "
               << tagS.simpleType() << "::add" << cnameS.plural().simpleType()
               << "(int count, int start) {" << std::endl
               << "   return m_" << cnameS << "_list.add(count,start);"
               << std::endl << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::delete"
               << cnameS.simpleType().plural()
               << "(int count, int start) {" << std::endl
               << "   m_" << cnameS << "_list.del(count,start);"
               << std::endl << "}" << std::endl << std::endl;
      }
      else
      {
         hFile << "inline " << cnameS.simpleType() << " &"
               << tagS.simpleType() << "::get" << cnameS.simpleType()
               << "() {" << std::endl
               << "   return m_" << cnameS << "_link.front();" << std::endl
               << "}" << std::endl << std::endl
               << "inline " << cnameS.listType() << " &" 
               << tagS.simpleType() << "::get" << cnameS.plural().simpleType()
               << "() {" << std::endl
               << "   return m_" << cnameS << "_link;" << std::endl
               << "}" << std::endl << std::endl
               << "inline " << cnameS.listType() << " "
               << tagS.simpleType() << "::add" << cnameS.plural().simpleType()
               << "(int count, int start) {" << std::endl
               << "   return m_" << cnameS << "_link.add(count,start);"
               << std::endl << "}" << std::endl << std::endl
               << "inline void " << tagS.simpleType() << "::delete"
               << cnameS.simpleType().plural()
               << "(int count, int start) {" << std::endl
               << "   m_" << cnameS << "_link.del(count,start);"
               << std::endl << "}" << std::endl << std::endl;
      }
   }

   if (tagS == "HDDM")
   {
      parentTable_t::iterator piter;
      for (piter = parents.begin(); piter != parents.end(); ++piter)
      {
         XtString cnameS(piter->first);
         if (cnameS != "HDDM" && element_in_list(cnameS,children[tagS]) == -1)
         {
            hFile << "inline " << cnameS.listType() << " "
                  << "HDDM::get" << cnameS.plural().simpleType() << "() {"
                  << std::endl << "   return " << cnameS.listType()
                  << "(&m_" << cnameS << "_plist," << std::endl
                  << "                   "
                  << "m_" << cnameS << "_plist.begin()," << std::endl
                  << "                   "
                  << "m_" << cnameS << "_plist.end());" << std::endl
                  << "}" << std::endl << std::endl;
         }
         if (cnameS != "HDDM")
         {
            cFile << std::endl
                  << "void debug_print(" << cnameS.listType() << " &list) {"
                  << std::endl
                  << "   list.debug_print();" << std::endl
                  << "}" << std::endl;
         }
      }
   }
}

/* Generate implementation code for data model classes */

void CodeBuilder::constructMethods(DOMElement* el)
{
   std::vector<DOMElement*>::iterator iter;
   for (iter = tagList.begin(); iter != tagList.end(); iter++)
   {
      writeClassimp(*iter);
   }
}

/* Generate methods for serializing classes to a stream and back again */

void CodeBuilder::writeStreamers(DOMElement* el)
{
   XtString tagS(el->getTagName());

   std::vector<XtString> attrV;
   DOMNamedNodeMap *myAttr = el->getAttributes();
   for (unsigned int n = 0; n < myAttr->getLength(); n++)
   {
      XtString attrS(myAttr->item(n)->getNodeName());
      XtString typeS(el->getAttribute(X(attrS)));
      if (typeS == "int" || typeS == "long" || typeS == "float" ||
          typeS == "double" || typeS == "boolean" || typeS == "string" ||
          typeS == "anyURI" || typeS == "Particle_t")
      {
         attrV.push_back(attrS);
      }
   }

   std::vector<XtString> contV;
   DOMNodeList* contList = el->getChildNodes();
   int contListLength = contList->getLength();
   for (int c = 0; c < contListLength; c++)
   {
      DOMNode* node = contList->item(c);
      if (node->getNodeType() == DOMNode::ELEMENT_NODE)
      {
         DOMElement *contEl = (DOMElement*)node;
         XtString contS(contEl->getTagName());
         XtString repS(contEl->getAttribute(X("maxOccurs")));
         int rep = (repS == "unbounded")? INT_MAX : atoi(S(repS));
         contV.push_back(contS + ((rep > 1)? "_list" : "_link"));
      }
   }

   hFile << "inline void " << tagS.simpleType() << "::streamer"
         << "(istream &istr) {" << std::endl;
   if (attrV.size()) {
      hFile << "   *istr.getXDRistream()";
      for (unsigned int n=0; n < attrV.size(); ++n)
      {
         hFile << " >> m_" << attrV[n];
      }
      hFile << ";" << std::endl;
   }
   if (contV.size()) {
      hFile << "   istr";
      for (unsigned int n=0; n < contV.size(); ++n)
      {
         hFile << " >> m_" << contV[n];
      }
      hFile << ";" << std::endl;
   }
   hFile << "}" << std::endl << std::endl;

   hFile << "inline void " << tagS.simpleType() << "::streamer"
         << "(ostream &ostr) {" << std::endl;
   if (attrV.size()) {
      hFile << "   *ostr.getXDRostream()";
      for (unsigned int n=0; n < attrV.size(); ++n)
      {
         hFile << " << m_" << attrV[n];
      }
      hFile << ";" << std::endl;
   }
   if (contV.size()) {
      hFile << "   ostr";
      for (unsigned int n=0; n < contV.size(); ++n)
      {
         hFile << " << m_" << contV[n];
      }
      hFile << ";" << std::endl;
   }
   hFile << "}" << std::endl << std::endl;
}

void CodeBuilder::constructStreamers(DOMElement* el)
{
   std::vector<DOMElement*>::iterator iter;
   for (iter = tagList.begin(); iter != tagList.end(); ++iter)
   {
      writeStreamers(*iter);
   }
}
 
/* Generate methods to read from binary stream into classes */

void CodeBuilder::constructIOstreams(DOMElement* el)
{
   hFile <<
   "inline istream::thread_private_data *istream::lookup_private_data() {\n"
   "   thread_private_data *my_private = my_thread_private[threads::getID()];\n"
   "   if (my_private != 0)\n"
   "      return my_private;\n"
   "   init_private_data();\n"
   "   return my_thread_private[threads::ID];\n"
   "}\n"
   "\n"
   "inline ostream::thread_private_data *ostream::lookup_private_data() {\n"
   "   thread_private_data *my_private = my_thread_private[threads::getID()];\n"
   "   if (my_private != 0)\n"
   "      return my_private;\n"
   "   init_private_data();\n"
   "   return my_thread_private[threads::ID];\n"
   "}\n"
   "\n"
   "inline void istream::skip(int count) {\n"
   "   MY_SETUP\n"
   "   MY(events_to_skip) += count;\n"
   "}\n"
   "\n"
   "inline bool istream::eof() {\n"
   "   MY_SETUP\n"
   "   return MY(hit_eof);\n"
   "}\n"
   "\n"
   "inline bool istream::operator!() {\n"
   "   return eof();\n"
   "}\n"
   "\n"
   "inline istream::operator void*() {\n"
   "   MY_SETUP\n"
   "   if (MY(hit_eof))\n"
   "      return NULL;\n"
   "   else\n"
   "      return this;\n"
   "}\n"
   "\n"
   "inline int istream::getCompression() const {\n"
   "   return (int)m_status_bits & k_bits_compression;\n"
   "}\n"
   "\n"
   "inline int ostream::getCompression() const {\n"
   "   return (int)m_status_bits & k_bits_compression;\n"
   "}\n"
   "\n"
   "inline int istream::getIntegrityChecks() const {\n"
   "   return (int)m_status_bits & k_bits_integrity;\n"
   "}\n"
   "\n"
   "inline int istream::getBytesRead() const {\n"
   "   int bytes = 0;\n"
   "   for (int i=1; i < threads::max_threads; ++i)\n"
   "      if (my_thread_private[i])\n"
   "         bytes += my_thread_private[i]->m_bytes_read;\n"
   "   return bytes;\n"
   "}\n"
   "\n"
   "inline int istream::getRecordsRead() const {\n"
   "   int records = 0;\n"
   "   for (int i=1; i < threads::max_threads; ++i)\n"
   "      if (my_thread_private[i])\n"
   "         records += my_thread_private[i]->m_records_read;\n"
   "   return records;\n"
   "}\n"
   "\n"
   "inline int ostream::getIntegrityChecks() const {\n"
   "   return (int)m_status_bits & k_bits_integrity;\n"
   "}\n"
   "\n"
   "inline int ostream::getBytesWritten() const {\n"
   "   int bytes = 0;\n"
   "   for (int i=1; i < threads::max_threads; ++i)\n"
   "      if (my_thread_private[i])\n"
   "         bytes += my_thread_private[i]->m_bytes_written;\n"
   "   return bytes;\n"
   "}\n"
   "\n"
   "inline int ostream::getRecordsWritten() const {\n"
   "   int records = 0;\n"
   "   for (int i=1; i < threads::max_threads; ++i)\n"
   "      if (my_thread_private[i])\n"
   "         records += my_thread_private[i]->m_records_written;\n"
   "   return records;\n"
   "}\n"
   "\n"
   "inline istream &istream::operator>>(streamable &object) {\n"
   "   MY_SETUP\n"
   "   if (MY(sequencing)) {\n"
   "      MY(codon)->m_target.push_back(&object);\n"
   "   }\n"
   "   else {\n"
   "      int size;\n"
   "      *MY(xstr) >> size;\n"
   "      if (size > 0) {\n"
   "         std::streampos start = MY(sbuf)->tellg();\n"
   "         sequencer(object);\n"
   "         MY(sbuf)->seekg(start+(std::streamoff)size);\n"
   "      }\n"
   "   }\n"
   "   return *this;\n"
   "}\n"
   "\n"
   "inline void istream::reset_sequencer() {\n"
   "   MY_SETUP\n"
   "   MY(sequencing) = 0;\n"
   "}\n"
   "\n"
   "inline void istream::sequencer(streamable &object) {\n"
   "   MY_SETUP\n"
   "   MY(sequencing) = 1;\n"
   "   MY(codon)->m_target.clear();\n"
   "   object.streamer(*this);\n"
   "   if (MY(sequencing)) {\n"
   "      MY(sequencing) = 0;\n"
   "      codon &gene = *MY(codon);\n"
   "      streamable null_streamable;\n"
   "      gene.m_target.push_front(&null_streamable);\n"
   "      chromosome::iterator iter;\n"
   "      for (iter = gene.m_sequence.begin();\n"
   "           iter != gene.m_sequence.end();\n"
   "           ++iter)\n"
   "      {\n"
   "         MY(codon) = &(*iter);\n"
   "         *this >> *gene.m_target[iter->m_order];\n"
   "      }\n"
   "      MY(codon) = &gene;\n"
   "   }\n"
   "}\n"
   "\n"
   "inline ostream &ostream::operator<<(HDDM &record) {\n"
   "   MY_SETUP\n"
   "   MY(sbuf)->reset();\n"
   "   *this << (streamable&)record;\n"
   "   while (MY(sbuf)->size() == MY(event_buffer_size)) {\n"
   "      delete MY(xstr);\n"
   "      delete MY(sbuf);\n"
   "      char *newbuf = new char[MY(event_buffer_size) *= 2];\n"
   "      MY(sbuf) = new ostreambuffer(newbuf, MY(event_buffer_size));\n"
   "      MY(xstr) = new xstream::xdr::ostream(MY(sbuf));\n"
   "      delete [] MY(event_buffer);\n"
   "      MY(event_buffer) = newbuf;\n"
   "      *this << (streamable&)record;\n"
   "   }\n" 
   "   lock_streambufs();\n"
   "   update_streambufs();\n"
   "   if ((MY(status_bits) & k_crc32_integrity) != 0) {\n"
   "      xstream::digest::crc32 crc;\n"
   "      std::ostream out(&crc);\n"
   "      out.write(MY(sbuf)->getbuf(),MY(sbuf)->size());\n"
   "      out.flush();\n"
   "      unsigned int crc32 = crc.digest();\n"
   "      *MY(xstr) << crc32;\n"
   "   }\n"
   "   MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());\n"
   "   if (!MY(ostr)->good()) {\n"
   "      unlock_streambufs();\n"
   "      throw std::runtime_error(\"hddm_"
                  << classPrefix << "::ostream::operator<< error - \"\n"
   "                               \"write error on event output!\");\n" 
   "   }\n" 
   "   if (MY(status_bits) & k_bz2_compression) {\n"
   "      MY(last_start) = ((xstream::bz::ostreambuf*)MY(xcmp))->get_block_start();\n"
   "      MY(last_offset) = ((xstream::bz::ostreambuf*)MY(xcmp))->get_block_offset();\n"
   "   }\n"
   "   else if (MY(status_bits) & k_z_compression) {\n"
   "      MY(last_start) = ((xstream::z::ostreambuf*)MY(xcmp))->get_block_start();\n"
   "      MY(last_offset) = ((xstream::z::ostreambuf*)MY(xcmp))->get_block_offset();\n"
   "   }\n"
   "   else {\n"
   "      MY(last_start) = m_ostr.tellp();\n"
   "      MY(last_offset) = 0;\n"
   "   }\n"
   "   unlock_streambufs();\n"
   "   MY(bytes_written) += MY(sbuf)->size();\n"
   "   MY(records_written)++;\n"
   "   return *this;\n"
   "}\n"
   "\n"
   "inline ostream &ostream::operator<<(streamable &object) {\n"
   "   MY_SETUP\n"
   "   *MY(xstr) << 0;\n"
   "   std::streampos start = MY(sbuf)->tellp();\n"
   "   object.streamer(*this);\n"
   "   std::streampos end = MY(sbuf)->tellp();\n"
   "   MY(sbuf)->seekp(start-std::streamoff(4));\n"
   "   *MY(xstr) << (int)(end-start);\n"
   "   MY(sbuf)->seekp(end);\n"
   "   return *this;\n"
   "}\n\n"
   ;
}

/* Generate the xml template in normal form and store in a string */

void CodeBuilder::constructDocument(DOMElement* el)
{
   static int indent = 0;
   hFile << "\"";
   for (int n = 0; n < indent; n++)
   {
      hFile << "  ";
   }
   
   XtString tagS(el->getTagName());
   hFile << "<" << tagS;
   DOMNamedNodeMap* attrList = el->getAttributes();
   int attrListLength = attrList->getLength();
   for (int a = 0; a < attrListLength; a++)
   {
      DOMNode* node = attrList->item(a);
      XtString nameS(node->getNodeName());
      XtString valueS(node->getNodeValue());
      hFile << " " << nameS << "=\\\"" << valueS << "\\\"";
   }

   DOMNodeList* contList = el->getChildNodes();
   int contListLength = contList->getLength();
   if (contListLength > 0)
   {
      hFile << ">\\n\"" << std::endl;
      indent++;
      for (int c = 0; c < contListLength; c++)
      {
         DOMNode* node = contList->item(c);
         if (node->getNodeType() == DOMNode::ELEMENT_NODE)
         {
            DOMElement* contEl = (DOMElement*) node;
            constructDocument(contEl);
         }
      }
      indent--;
      hFile << "\"";
      for (int n = 0; n < indent; n++)
      {
         hFile << "  ";
      }
      hFile << "</" << tagS << ">\\n\"" << std::endl;
   }
   else
   {
      hFile << " />\\n\"" << std::endl;
   }
}

std::string guessType(const std::string &literal)
{
   const char *str = literal.c_str();
   char *endptr;
   errno=0;
   long long int llvalue = strtoll(str,&endptr,0);
   if (errno == 0 && *endptr == 0) {
      errno=0;
      int lvalue = strtol(str,&endptr,0);
      if (errno == 0 && *endptr == 0 && lvalue == llvalue) {
         return "int";
      }
      else {
         return "long";
      }
   }
   errno=0;
   strtof(str,&endptr);
   if (errno == 0 && *endptr == 0) {
      return "float";
   }
   errno=0;
   strtod(str,&endptr);
   if (errno == 0 && *endptr == 0) {
      return "double";
   }
   if (literal == "true" || literal == "false") {
      return "boolean";
   }
   if ((int)lookupParticle(literal) != 0) {
      return "Particle_t";
   }
   if (XMLUri::isValidURI(false,X(literal))) {
      return "anyURI";
   }
   return "string";
}

Particle_t lookupParticle(const std::string &name)
{
   for (int p=0; p<100; ++p) {
      if (ParticleType((Particle_t)p) == name) {
         return (Particle_t)p;
      }
   }
   return Unknown;
}
